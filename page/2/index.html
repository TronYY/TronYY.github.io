<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="戒骄戒躁">
<meta name="keywords" content="Technology">
<meta property="og:type" content="website">
<meta property="og:title" content="天洋行空">
<meta property="og:url" content="https://tronyy.github.io/archives/page/2/index.html">
<meta property="og:site_name" content="天洋行空">
<meta property="og:description" content="戒骄戒躁">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="天洋行空">
<meta name="twitter:description" content="戒骄戒躁">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tronyy.github.io/archives/page/2/"/>





  <title>天洋行空</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">天洋行空</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tronyy.github.io/archives/2020/06/06/C-Primer-读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天洋行空">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天洋行空">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/06/C-Primer-读书笔记/" itemprop="url">C++ Primer 读书笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-06T11:34:26+08:00">
                2020-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<h1 id="第2章-变量与基本类型"><a href="#第2章-变量与基本类型" class="headerlink" title="第2章 变量与基本类型"></a>第2章 变量与基本类型</h1><h3 id="2-2-1-变量定义"><a href="#2-2-1-变量定义" class="headerlink" title="2.2.1 变量定义"></a>2.2.1 变量定义</h3><ul>
<li>如果是内置类型的变量未被显示初始化，它的值由定义的位置决定:定义于任何函数体之外的变量被初始化为0;定义于函数体内部的内置类型变量将不被初始化</li>
<li><p>不提供显式的值也能初始化——零初始化</p>
<ul>
<li>全局变量p</li>
<li>静态变量</li>
<li>类内静态变量<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">//在一个块中</span></span><br><span class="line">    <span class="keyword">int</span> i;<span class="comment">//默认初始化，不可直接使用</span></span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;<span class="comment">//值初始化</span></span><br><span class="line">    j=<span class="number">1</span>;<span class="comment">//赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>绝大多数类都支持无须显示初始化而定义对象，如std::string empty;//empty非显示地初始化为一个空串</p>
</li>
<li>默认构造函数：A default constructor is a constructor which can be called with no argument<blockquote>
<p>声明： 在环境/上下文中指定一个变量的名字。也就是说，声明仅仅是让编译器知道，而没有实际分配空间。<br>初始化：给一个声明后尚未初始化的变量一个有意义的初始值。<br>赋值 ： 销毁一个变量原来的值，并赋予一个新值。相当于改变了一个变量的状态</p>
<ul>
<li>值初始化： 值初始化是定义对象时，要求初始化，但没有给出初始值的行为。<br>int i{};<br>new int();<br>new int{}; //C++11<br>（1）在数组初始化的过程中，如果提供的初始值数量少于数组的大小，剩下的元素会进行值初始化；<br>（2）静态static变量、定义在块作用域外的全局变量，<strong>如果没有显式的初始值</strong>，将执行值初始化；<br>（3）当我们通过书写形如T()的表达式（例如 int()）显式地请求值初始化时;<br>默认初始化：默认初始化是定义对象时，没有使用初始化器，也即没有做任何初始化说明时的行为。如：<br>int i;<br>vector<int> v;<br>new T;<br>（1）当我们在块作用域内（类内也属于块作用域内）不使用任何初始值定义一个非静态变量时；<br>（2）当一个类本身含有类类型成员且使用合成的<strong>默认构造函数</strong>时；<br>（3）当类类型的成员<strong>没有在构造函数初始值列表中</strong>显式地初始化时;  </int></li>
</ul>
</blockquote>
</li>
<li>默认构造函数是编译器自动合成的，默认初始化之前先进行零初始化 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> foo() = <span class="keyword">default</span>;</span><br><span class="line"> <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> bar();</span><br><span class="line"> <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">bar::bar() = <span class="keyword">default</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> foo a&#123;&#125;;</span><br><span class="line"> bar b&#123;&#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a.a &lt;&lt; <span class="string">'\t'</span> &lt;&lt; b.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>答案是a.a是0，b.b是不确定，foo的构造函数在起初声明时是要求默认合成，而不是我们自定义提供的，因此它属于编译器合成的默认构造函数。而bar的构造函数则不同，它是在定义时被要求合成，因此它属于我们用户自定义的默认构造函数。</p>
<ul>
<li>函数内的初始化，初始化数组 和 指针<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[<span class="number">12</span>];</span><br><span class="line"><span class="built_in">memset</span>(flag, <span class="literal">true</span>, <span class="keyword">sizeof</span>(flag));	</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">当初始化一个字节单位的数组时，可以用memset把每个数组单元初始化成任何你想要的值 ，</span></span><br><span class="line"><span class="comment">但是不是一个字节单位时一般只能0 或 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">bool</span> *flag=<span class="keyword">new</span> <span class="keyword">bool</span>[<span class="number">12</span>];</span><br><span class="line"><span class="built_in">memset</span>(flag, <span class="literal">false</span>, <span class="number">12</span>*<span class="keyword">sizeof</span>(<span class="keyword">bool</span>));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-2-变量声明和定义的关系"><a href="#2-2-2-变量声明和定义的关系" class="headerlink" title="2.2.2 变量声明和定义的关系"></a>2.2.2 变量声明和定义的关系</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;<span class="comment">//声明i，没有定义i</span></span><br><span class="line"><span class="keyword">int</span> j;<span class="comment">//声明且定义了j</span></span><br></pre></td></tr></table></figure>
<ul>
<li>变量能且只能被定义一次，但是可以被多次声明。因此，变量的定义只能出现在一个文件中，其他用到该变量的文件必须对其进行声明<h2 id="2-3-复合类型"><a href="#2-3-复合类型" class="headerlink" title="2.3 复合类型"></a>2.3 复合类型</h2><h3 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h3></li>
<li>实现了对其他对象的间接引用。本身就是一个对象，允许赋值和拷贝，生命周期内可以先后指向多个不同的对象。其二 无须在定义时赋值</li>
<li>空指针 nullptr/0</li>
<li>建议初始化所有的指针。尽量等先定义了对象再定义指向它的指针</li>
<li>void<em>可以用于存放任意对象的地址。能做的事情比较有限——拿他与别的指针比较、作为函数的输入输出、赋值给另外的void </em>指针。++不能直接操作void * 所指的对象++(包括访问)</li>
<li>指针和引用的主要区别：<blockquote>
<p>definition:<br>the pointer is “points to” any other type.<br>the reference is “another name” of an object.<br>key difference:<br>(1) a reference is another name of an already existing object. a pointer is an object in its own right.<br>(2) Once initialized, a reference remains bound to its initial object. There is no way to rebind a reference to refer to a different object. a pointer can be assigned and copied.<br>(3)a reference always get the object to which the reference was initially bound. a single pointer can point to several different objects over its lifetime.<br>(4)a reference must be initialized. a pointer need not be initialized at the time it is defined.</p>
</blockquote>
</li>
</ul>
<p>-给定一个指针，无法知道是否指向了一个合法的对象</p>
<h3 id="2-3-3-理解复合类型的声明"><a href="#2-3-3-理解复合类型的声明" class="headerlink" title="2.3.3 理解复合类型的声明"></a>2.3.3 理解复合类型的声明</h3><ul>
<li>指向指针的引用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;  </span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;<span class="comment">//r 是一个对指针p的引用。要理解r的类型是什么，最简单的方法时从右往左阅读r 的含义。离变量名最近的符号对变量的类型有最直接的影响  </span></span><br><span class="line">r = &amp;i;<span class="comment">//令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>;<span class="comment">//解引用r得到i，这句将i值改为0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h2><ul>
<li><strong>const对象必须初始化</strong></li>
<li>const对象仅在文件内有效：编译器在编译过程中把用到该变量的地方都替换成对应的值，因此需要在编译阶段 用到了const的文件都必须能访问到它的初始值，即 需要该文件中有对const对象的定义。默认下，const对象被设定为仅在文件内有效。想在多个文件之间共享const对象，必须在变量的定义之前添加extern对象<h3 id="2-4-1-const的引用"><a href="#2-4-1-const的引用" class="headerlink" title="2.4.1 const的引用"></a>2.4.1 const的引用</h3></li>
<li><p><strong>不能让一个非常量引用指向一个常量对象。常量引用可以绑定非常量对象，但是不允许通过该引用修改原对</strong>象——<strong>指向常量对象的也必须是常量引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci;<span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i;</span><br><span class="line">r3 = <span class="number">0</span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用的类型必须与其所引用对象的类型一致。但是两个例外:<br>(1) 初始化常量引用时，允许用任意表达式作为初始值，只要该表达式结果能转换成引用的类型；  (常量引用是对const的引用）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>;<span class="comment">//错误 r4非常量引用</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure>
<p>等价于<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval;<span class="comment">//临时量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure></p>
<p>(2) 如果ri不是常量引用，就允许对ri赋值，会改变ri所引用的对象的值——临时量，但是闲着没事干改临时量干什么，改了temp也不会对应改到dval，所以ri不是常量引用的话就会出错了</p>
<h3 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h3><p>-指向常量的指针<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cprt = &amp;pi;<span class="comment">//cptr是指向双精度常量的指针，不能通过该指针修改所指对象的值，但是cprt可以指向其他的双精度</span></span><br></pre></td></tr></table></figure></p>
<p><strong>const放在最前边表示指向的是一个const对象</strong></p>
<ul>
<li>const指针<br>必须初始化<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb; <span class="comment">//const前加*表示指针是一个常量，存的地址不能变了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.1415</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;<span class="comment">//第一个const表示指向的对象是一个常量，不能通过改指针修改所指对象的值；第二个const表示该指针是个const指针，不能指向其他对象</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-4-3-顶层const"><a href="#2-4-3-顶层const" class="headerlink" title="2.4.3 顶层const"></a>2.4.3 顶层const</h3><ul>
<li>const expression是指值不会改变并且在编译过程中就能得到计算结果的表达式<br>如 int s = 27与const int sz =get_size()都不是const expression，前者值不是 const 后者值要到运行时才能知道<br>-顶层const表示本身是个常量；底层const表示所指的是个常量（写在最前面的const）</li>
</ul>
<h3 id="2-4-4-constexpr"><a href="#2-4-4-constexpr" class="headerlink" title="2.4.4 constexpr"></a>2.4.4 constexpr</h3><ul>
<li>constexpr 初始值必须是存储于某个固定地址中的对象(函数体外的变量 或函数体内局部静态变量)<h2 id="2-5-处理类型"><a href="#2-5-处理类型" class="headerlink" title="2.5 处理类型"></a>2.5 处理类型</h2><h3 id="2-5-1-类型别名"><a href="#2-5-1-类型别名" class="headerlink" title="2.5.1 类型别名"></a>2.5.1 类型别名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;<span class="comment">//pstring的基本数据类型是指针</span></span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>;<span class="comment">//cstr 是指向char的常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cstr = <span class="number">0</span>;<span class="comment">//声明了一个指向const char的指针  所以不能错误地长是把类型别名替换成它本来的样子</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-5-2-auto"><a href="#2-5-2-auto" class="headerlink" title="2.5.2 auto"></a>2.5.2 auto</h3><ul>
<li>auto定义的变量必须有初始值</li>
<li>auto会忽略掉顶层const，底层const会被保留下来</li>
</ul>
<h3 id="2-5-3-decltype类型指示符"><a href="#2-5-3-decltype类型指示符" class="headerlink" title="2.5.3 decltype类型指示符"></a>2.5.3 decltype类型指示符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>; <span class="comment">// x的类型是const int</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">decltype</span>(*p) 结果是引用类型。解引用指针可以得到指针所指的对象，而且还能给这个对象赋值，因此<span class="keyword">decltype</span>(*p) 结果是<span class="keyword">int</span>&amp; 并非<span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<ul>
<li>decltype((variable))的结果永远是引用，decltype(variable)只有当variable本身就是一个引用时才是引用</li>
</ul>
<h2 id="2-6-自定义数据结构"><a href="#2-6-自定义数据结构" class="headerlink" title="2.6 自定义数据结构"></a>2.6 自定义数据结构</h2><ul>
<li>#ifdef 当且仅当变量已经定义时为真， #ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直到遇到#endif为止</li>
</ul>
<h1 id="第3章-字符串、向量和数组"><a href="#第3章-字符串、向量和数组" class="headerlink" title="第3章 字符串、向量和数组"></a>第3章 字符串、向量和数组</h1><h2 id="3-1-命名空间的using声明"><a href="#3-1-命名空间的using声明" class="headerlink" title="3.1 命名空间的using声明"></a>3.1 命名空间的using声明</h2><ul>
<li>头文件不应包含using声明<h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h2></li>
<li>读取string时，会自动忽略开头的空白（包括换行符制表符），并从第一个真正的字符开始读起，直到遇到下一处空白</li>
<li>C++输出十六进制是cout〈〈hex〈〈 a；而八进制是cout〈〈 ocx〈〈 a;二进制则没有默认的输出格式，需要自己写函数进行转换</li>
<li>cin完，再getline 此时读完的还是只有第一行</li>
<li></li>
</ul>
<h3 id="3-2-2-string对象上的操作"><a href="#3-2-2-string对象上的操作" class="headerlink" title="3.2.2 string对象上的操作"></a>3.2.2 string对象上的操作</h3><ul>
<li>getline遇到换行符结束，读入的不含那个换行符</li>
<li>size函数返回的是一个无符号整型数，比较得和无符号数比较</li>
<li>当吧string对象和字符字面值及字符串字面值混在一条语句中时，必须确保每个加法运算符两侧的运算对象至少一个string。注意字符串字面值与string是不同的类型</li>
<li>string 到 int的 转换  stoi(44)</li>
<li><p>使用for语句改变字符串中的字符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);<span class="comment">//对于s中每个字符使用引用，转换成大写</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>str.size()  str.size() str.append(8-str.size(),’0’)  string pp(kk.end() - kk.begin(), ‘0’); string pp(kk.end() - kk.begin(), ‘0’);</p>
</li>
<li>逆转 reverse()&amp;reverse_copy()  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">reverse(a,a+<span class="number">10</span>);   </span><br><span class="line">reverse_copy(a,a+<span class="number">10</span>,b); <span class="comment">//倒序放入b数组中</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">reverse</span> (<span class="title">BidirectionalIterator</span> <span class="title">first</span>, <span class="title">BidirectionalIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> ((first!=last)&amp;&amp;(first!=--last))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::iter_swap (first,last);</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a>3.3 标准库类型vector</h2><h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1 定义和初始化vector对象"></a>3.3.1 定义和初始化vector对象</h3><ul>
<li>vector 是模版而非类型</li>
<li>引用不能作为vector包含的元素，因为所包含的必须是对象</li>
<li>列表初始化（用花括号扩起来，里面填上0个或多个元素赋给对象）,花括号里的值必须和元素类型相同 vector<string> v8{10, “hi”}不是列表初始化,编译器尝试用默认值初始化vector对象——v8有10个值为”hi”的元素。  vector<string> v7{10} v7有10个默认初始化的元素</string></string></li>
<li>map&lt;char, int&gt; mp; mp[c] = 5;</li>
<li>list<int> l; l.erase(迭代器)</int></li>
<li>如果vector对象的元素是内置类型，如int，则元素的初始值自动设为0；如果元素是某种类型，比如string，则元素由类默认初始化</li>
</ul>
<h3 id="3-3-2-向vector对象中添加元素"><a href="#3-3-2-向vector对象中添加元素" class="headerlink" title="3.3.2 向vector对象中添加元素"></a>3.3.2 向vector对象中添加元素</h3><ul>
<li>v.push_back(i) 插到尾端</li>
<li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type;<span class="comment">//vector对象的类型总是包含着元素的类型</span></span><br><span class="line"><span class="built_in">vector</span>::size_type;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>到中间一个数为止（总数是奇数，过了中间一个数为止；总数是偶数，到前半部分为止），&lt;(size() + 1) / 2</p>
</li>
</ul>
<h2 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a>3.4 迭代器介绍</h2><ul>
<li>所有的标准库容器对象都可以使用迭代器，但是其中少数才同时支持下标运算符。严格来说string对象不属于容器类型，但是string支持很多与容器类型类似的操作 </li>
<li>使用容器养成使用迭代器和== !=的习惯</li>
<li>能进行算术运算的迭代器只有随即访问迭代器，要求容器元素存储在连续内存空间里，vector，string，deque的迭代器是有加减法的，但是map，set，multimap,multiset的迭代器是没有加减法的，list也不可以。map等的迭代器不支持加减操作，仅有++itr，–-itr这些操作来进行选择</li>
<li>不要在循环中判断不等于end()</li>
</ul>
<h3 id="3-4-1-使用迭代器"><a href="#3-4-1-使用迭代器" class="headerlink" title="3.4.1 使用迭代器"></a>3.4.1 使用迭代器</h3><ul>
<li><p>auto e = v.end();//e表示v尾元素的下一位置<br>v.begin() == v.end() 表示v为空，返回的都是尾后迭代器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把string对象的第一个单词改写为大写形式</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it != s.end() &amp;&amp; !<span class="built_in">isspace</span>(*it); ++it)</span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);<span class="comment">// *it返回的是it所指元素的引用</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);<span class="comment">//对于s中每个字符使用引用，转换成大写</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="comment">//注意使用迭代器时用引用还是直接里面的对象。要修改则用引用&amp;如② 或 解引用如①</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="built_in">string</span>::iterator it2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;<span class="comment">//只能读</span></span><br><span class="line"><span class="built_in">string</span>::const_iterator it4;<span class="comment">//只能读</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为了便于得到const_iterator类型 auto it3 = v.cbegin(); cend()</p>
</li>
<li>检查it所指字符串是否为空 (<em>it).empty() 而不是 </em>it.empty()</li>
<li>箭头运算符 把解引用和成员访问两个操作结合在一起 it-&gt;men  同 (*it).mem</li>
<li>凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素<h3 id="3-4-2-迭代器运算"><a href="#3-4-2-迭代器运算" class="headerlink" title="3.4.2 迭代器运算"></a>3.4.2 迭代器运算</h3></li>
<li>vector与string迭代器支持的运算+n -n +=n -=n - &gt; &lt; &gt;= &lt;=, 其中- 得出的类型是difference_type 带符号整型数</li>
</ul>
<h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><ul>
<li>引用不能作为数组包含的元素，因为所包含的必须是对象</li>
<li>不能用数组为其他数组赋值 如a2 = a，数组首元素是个常量指针const char* ;错误 （但是Java里a2 = a可以的，是一种浅层复制，把数组的引用指向了a2，a2一变a也会变）</li>
<li>数组的维度必须是constexpr（指值不会改变并且在编译过程中就能得到计算结果的表达式）</li>
<li><em>与[]后者优先，理解数组声明最好从数组的名字开始按照由内向外的顺序阅读<br>int </em>(&amp;array)[10] = ptrs;//array 是一个含有10个int型指针的数组的  引用</li>
<li>不能直接把数组作为返回值 见剑指offer网 序列化二叉树</li>
</ul>
<h3 id="3-5-2-访问数组元素"><a href="#3-5-2-访问数组元素" class="headerlink" title="3.5.2 访问数组元素"></a>3.5.2 访问数组元素</h3><ul>
<li>数组下标类型size_t 无符号类型</li>
<li>遍历数组时，最好的方法也是使用for御语句<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : score)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;<span class="comment">//ia是一个整型数组指向ia的第一个元素 实际上编译器中发生的是auto ia2(&amp;ia[]);  当使用decltype关键字时，这个转换不会发生，ia2将是数组</span></span><br></pre></td></tr></table></figure>
<ul>
<li>指向数组ia首元素的指针 int *beg = begin(ia); 尾元素后一位置的指针 end(ia)</li>
<li><p>两个指针相减类型 ptrdiff_t类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ia[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> k = p[<span class="number">-2</span>];<span class="comment">//标准库类型如string 和vector限定下标必须是无符号类型，内置的下标运算则无此要求</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组元素是否相等要一个个比较，两个vector对象是否相等可以直接==比较</p>
</li>
<li>判断数组为空用nullptr，如果一位数组arr不为空，sizeof(arr)/sizeof(arr[0)就可以用来计算数组长度，但是如果arr是作为形参传入函数体，arr是一个指针，sizeof(arr) 是为8，不是数组总大小；同样地end(arr) - begin(arr) 当arr是传入参数时也不可以使用可以用nullptr、sizeof(arr) == 0来判断</li>
</ul>
<h3 id="3-5-5-与旧代码的接口"><a href="#3-5-5-与旧代码的接口" class="headerlink" title="3.5.5 与旧代码的接口"></a>3.5.5 与旧代码的接口</h3><ul>
<li>不能用string对象初始化char*</li>
<li><p>不允许用vector初始化数组，不允许数组初始化数组，但是允许数组初始化vector，如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(begin(int_arr), end(int_arr));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(int_arr + <span class="number">1</span>, int_arr + <span class="number">4</span>);<span class="comment">//三个元素，分别为int_arr[1]、[2]、[3];</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量使用vector和迭代器，避免使用内置数组和指针，尽量使用string避免使用c风格的基于数组的字符串</p>
<h2 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h2></li>
<li><p>对每个元素赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">row要写成引用，row的类型是含有4个整数的数组的引用。</span></span><br><span class="line"><span class="comment">如果row不写成引用类型，编译无法通过——外层要遍历一个个大小为4的数组，row不是引用类型的话，编译器初始化row时会自动将这些数组元素转换成指向该数组首元素的指针.</span></span><br><span class="line"><span class="comment">这样row的类型就是int*  内层循环就不合理了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia) </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row) &#123;</span><br><span class="line">        col = cnt;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用for循环语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = </span><br><span class="line">    &#123; </span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">        &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;,</span><br><span class="line">        &#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>(&amp;row)[<span class="number">4</span>] : arr)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col : row) <span class="built_in">cout</span> &lt;&lt; col &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for loop</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j != <span class="number">4</span>; ++j) <span class="built_in">cout</span> &lt;&lt; arr[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using pointers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>(*row)[<span class="number">4</span>] = arr; row != arr + <span class="number">3</span>; ++row)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> *col = *row; col != *row + <span class="number">4</span>; ++col) <span class="built_in">cout</span> &lt;&lt; *col &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第4章-表达式"><a href="#第4章-表达式" class="headerlink" title="第4章 表达式"></a>第4章 表达式</h1><h2 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h2><h3 id="4-1-1-基本概念"><a href="#4-1-1-基本概念" class="headerlink" title="4.1.1 基本概念"></a>4.1.1 基本概念</h3><ul>
<li>当一个对象被当做右值的时候，用的是对象的值（内容），当对象被当做左值的时候，用的是对象的身份（在内存中的位置）</li>
<li>取地址符得到的结果是右值。解引用、下标运算符的结果是左值</li>
<li>表达式求值结果是左值（如解引用），decltype以后得到一个引用类型。取地址运算符生成右值，所以decltype(&amp;p) 结果是int<em>，（p是 int</em>类别）</li>
<li>优先级 去掉一个最高的，去掉一个最低的，剩下的是一、二、三、赋值。双目运算符中，顺序为算术、关系和逻辑，移位和逻辑位插入其中。<h2 id="4-5-递增和递减运算符"><a href="#4-5-递增和递减运算符" class="headerlink" title="4.5 递增和递减运算符"></a>4.5 递增和递减运算符</h2></li>
<li>递增后置版本，先将变量的值+1，再返回变量初始值的副本<h2 id="4-9-sizeof运算符"><a href="#4-9-sizeof运算符" class="headerlink" title="4.9 sizeof运算符"></a>4.9 sizeof运算符</h2></li>
<li>sizeof并不实际计算其运算对象的值。对解引用指针执行sizeof运算的带指针所指对象所占空间的大小，指针不需要有效。sizeof（数组）是计算整个数组所占空间的大小，不会把数组当成指针来处理</li>
<li></li>
</ul>
<h1 id="第6章-函数"><a href="#第6章-函数" class="headerlink" title="第6章 函数"></a>第6章 函数</h1><h1 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h1><h3 id="6-1-1-局部对象"><a href="#6-1-1-局部对象" class="headerlink" title="6.1.1 局部对象"></a>6.1.1 局部对象</h3><ul>
<li>自动对象：只存在于块执行期间的对象称为自动对象，比如里面的a，还有我们的形参，都是自动对象。<br>局部静态对象在程序执行路径第一次经过对象定义语句时初始化，知道程序终止才被销毁（只被定义初始化一次，可以一直用它）static int cnt = 0；如果静态变量没有显式的初始值，它将执行默认初始化。</li>
</ul>
<h3 id="6-1-2-函数声明"><a href="#6-1-2-函数声明" class="headerlink" title="6.1.2 函数声明"></a>6.1.2 函数声明</h3><ul>
<li>函数三要素（返回类型，函数名，形参类型）描述了函数接口<br>//也就是说明了调用该函数所需的全部信息</li>
<li>定义函数的源文件还要把含有函数声明的头文件包含进来<h1 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h1><h2 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h2></li>
<li>指针形参，拷贝的是指针的值<h2 id="6-2-2-传引用参数"><a href="#6-2-2-传引用参数" class="headerlink" title="6.2.2 传引用参数"></a>6.2.2 传引用参数</h2></li>
<li>一个函数只能返回一个值，然而有时候函数需要同时返回多个值，考虑引用参数<h2 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3 const形参和实参"></a>6.2.3 const形参和实参</h2></li>
<li>顶层const，即对象本身是常量，int 可以直接赋值给const int（只是不能通过后者修改；反过来不行）我们在拷贝时会忽略顶层const。void f(const int i){}和void f(int i){}属于重复定义<br>注意与下面第二章的区别“不能让一个非常量引用指向一个常量对象。常量引用可以绑定非常量对象，但是不允许通过该引用修改原对象——指向常量对象的也必须是常量引用”</li>
<li>可以用非常量初始化一个底层const对象（所指向的是个常量），反过来不行</li>
</ul>
<ul>
<li>尽量使用常量引用<blockquote>
<p>只要不需要改变形参的值，都尽量用常量，理由有两点：  </p>
<ul>
<li>该用常量而不用常量，会给函数的调用者一种误导，即函数可以改变它的实参的值  </li>
<li>使用引用而非常量引用会限制函数所能接受的实参类型。刚刚就学过，我们不能把const给非const的，但可以把非const的给const。</li>
</ul>
</blockquote>
<h3 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a>6.2.4 数组形参</h3><blockquote>
<p>数组不允许被拷贝：所以无法使用值传递<br>使用数组名时会将其转换为指针</p>
</blockquote>
</li>
<li>只会检查传入的参数是不是const int*类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下三个函数声明等价（还记得函数声明吧）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>; <span class="comment">//数组名转换为数组首元素指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">5</span>])</span></span>; <span class="comment">//我们期望它有五个元素，其实都行</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *m[<span class="number">10</span>];<span class="comment">//10个指针构成的数组</span></span><br><span class="line"><span class="keyword">int</span> （*matrix)[<span class="number">10</span>];<span class="comment">//指向含有10个整数的数组的指针</span></span><br></pre></td></tr></table></figure>
<ul>
<li>void print(const int ia[10]) 与const int*一样，不会去管里面几个。如果要传10个，应写成const int (&amp;a)[10]<h3 id="6-2-5-main-处理命令行选项"><a href="#6-2-5-main-处理命令行选项" class="headerlink" title="6.2.5 main:处理命令行选项"></a>6.2.5 main:处理命令行选项</h3></li>
<li>省略符形参<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, ...)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"> f(a,<span class="number">6</span>);</span><br><span class="line"> f(a, <span class="string">"a"</span>); <span class="comment">//懂了吧~</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-3-3-返回数组指针"><a href="#6-3-3-返回数组指针" class="headerlink" title="6.3.3 返回数组指针"></a>6.3.3 返回数组指针</h3><ul>
<li>因为数组不能被拷贝，所以函数不能返回数组，只能返回数组的指针或者引用。</li>
</ul>
<p><code>int (*f())[10]; //函数返回的是指针，指向一个大小为10的int数组</code></p>
<ul>
<li>因为这样看起来比较麻烦，我们可以用之前学过的类型别名：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> arr = <span class="keyword">int</span>[<span class="number">10</span>];  </span><br><span class="line"><span class="function">arr* <span class="title">f</span><span class="params">()</span></span>; <span class="comment">//这样的声明就比较简洁了</span></span><br></pre></td></tr></table></figure>
<ul>
<li>除了使用类型别名外，C++还有一种方法：尾置返回类型，顾名思义，就是把返回类型放后面：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f() -&gt; int(*)[10]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>别忘了我们还有一个神器，decltype：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(a) *arrp()&#123;&#125; <span class="comment">//返回类型是指针，且指向的类型与a一致</span></span><br><span class="line"><span class="comment">//使用它的前提是我们知道返回的指针指向什么类型的数组。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h2><ul>
<li>重载和const形参<br>一句话概括：顶层const（本身为常量）重载不行的，会被忽略，什么意思呢，看代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>)</span></span>; <span class="comment">//重复声明，顶层const会被忽略</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>底层const重载是可行的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span> <span class="comment">//重载，常量引用都是底层const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> *a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *a)</span></span>; <span class="comment">//重载，指向常量的指针</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-4-1-重载与作用域"><a href="#6-4-1-重载与作用域" class="headerlink" title="6.4.1 重载与作用域"></a>6.4.1 重载与作用域</h3><ul>
<li>如果在内层作用域中声明名字，它将隐藏外层作用域中的同名实体。在不同的作用域中无法重载函数名</li>
<li>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。</li>
</ul>
<h1 id="第7章-类"><a href="#第7章-类" class="headerlink" title="第7章 类"></a>第7章 类</h1><h2 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1 定义抽象数据类型"></a>7.1 定义抽象数据类型</h2><ul>
<li><code>一个函数
AcGePoint3dstartPoint() const;
const放在后面跟前面有区别么</code><br>==&gt;<br>准确的说const是修饰this指向的对象的<br>譬如，我们定义了<br>classA{<br>public:<br>f(int);<br>};<br>这里f函数其实有两个参数，第一个是A*const this, 另一个才是int类型的参数<br>如果我们不想f函数改变参数的值，可以把函数原型改为f(constint),但如果我们不允许f改变this指向的对象呢？因为this是隐含参数，const没法直接修饰它，就加在函数的后面了，表示this的类型是constA *constthis。<br>const修饰*this是本质  该成员函数成为<strong>常量成员函数</strong>， this 指向对象，对象是常量对象</li>
<li>加了const 表明在函数体内，不能修改对象的数据成员，且只能调用常量成员函数</li>
<li>常量对象，以及常量对象的引用或者指针都只能调用常量成员函数</li>
<li>调用total.isbn() 编译器实际上将该调用重写成了Sales_data::isbn(&amp;total)</li>
<li>void fun(int a，int b) const{}<br>void const fun(int a,int b){}，const都是在修饰this，与const所写的位置无关。<h3 id="7-1-3-定义类相关的非成员函数"><a href="#7-1-3-定义类相关的非成员函数" class="headerlink" title="7.1.3 定义类相关的非成员函数"></a>7.1.3 定义类相关的非成员函数</h3></li>
<li>IO类型属于不能被拷贝的类型，所以IO类型作为参数时，需要用引用</li>
<li>拷贝类的对象实际上拷贝的是对象的数据成员</li>
<li>非成员函数（个人觉得就是如果定义写在类外，定义时有没有加所属的类名）。另外，如果是非成员函数，其定义一般与声明写在一个头文件中</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;; <span class="comment">// 这个就是成员函数。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">// 这个也是成员函数声明，其实现在类的外部。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> A::f2()&#123;&#125; <span class="comment">// 这个是成员函数的实现。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;&#125;; <span class="comment">// 这个就是非成员函数，它不属于A，也不属于任何一起其他的类。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//print自己写</span></span><br></pre></td></tr></table></figure>
<h3 id="7-1-4-构造函数"><a href="#7-1-4-构造函数" class="headerlink" title="7.1.4 构造函数"></a>7.1.4 构造函数</h3><ul>
<li>构造函数不能被声明成const（常量成员函数）</li>
<li>编译器只有在我们没有定义构造函数时，才会生成默认构造函数，也就是说，如果我们定义了一个构造函数，且它不是默认构造函数，那我们就没有默认构造函数可以使用了。</li>
<li><img src="https://uploadfiles.nowcoder.com/images/20190918/5783209_1568785737405_78E33A3CE76B90C654374A989D593EB7" alt="image"></li>
<li>最好把默认构造函数加上</li>
<li>Sales_data() = default;= //default的意思是，我们要求编译器生成构造函数。= default在类内部是内联，在类外部不是内联。</li>
<li>构造函数初始值列表。当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p) :</span><br><span class="line">            (bookNo(s), units_sold(n), revenue(p*n)) &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h2><ul>
<li>struct和class的唯一的区别是默认访问权限不太一样。<br>struct：定义在第一个访问说明符之前的成员是public<br>class：定义在第一个访问说明符之前的成员是private<h3 id="7-2-1-友元"><a href="#7-2-1-友元" class="headerlink" title="7.2.1 友元"></a>7.2.1 友元</h3></li>
<li><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（与成员函数权利一样） 加friend</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>友元声明只能卸载类定义的内部，具体位置不限。友元不受它所在区域访问控制级别的约束。</p>
</li>
<li>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。所以需要在友元声明之外再专门对函数进行一次声明</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//数据成员</span></span><br><span class="line">    <span class="built_in">string</span> bookNo; <span class="comment">//书号</span></span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>; <span class="comment">//售出册数</span></span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0</span>; <span class="comment">//总销售收入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> <span class="comment">//返回书本isbn号，这里的const待会解释</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>; <span class="comment">//函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//返回售出书籍的均价，这里的const也待会解释</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream&amp;, Sales_data&amp;)</span> <span class="comment">//声明在类外且无作用域符号，为非成员函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a>7.3 类的其他特性</h2><h3 id="7-3-1-类成员再探"><a href="#7-3-1-类成员再探" class="headerlink" title="7.3.1 类成员再探"></a>7.3.1 类成员再探</h3><ul>
<li>定义在类内部的成员函数是自动inline的。最好只在类外部定义的地方说明inline，更好理解。inline函数放在头文件中</li>
<li>可变数据成员加mutable， 永远不是const，即使他是const对象的成员，一个宠上天成员函数也可以改变一个成员的值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Screen&gt; screens&#123; Screen(<span class="number">24</span>, <span class="number">80</span>, <span class="string">' '</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们用了列表初始化去初始screens这个Window_mgr类的类内成员变量，</span></span><br><span class="line"><span class="comment">//在列表初始化内容中，我们调用了Screen类的构造函数去实例化一个匿名对象。</span></span><br></pre></td></tr></table></figure>
<h4 id="基于const的重载"><a href="#基于const的重载" class="headerlink" title="基于const的重载"></a>基于const的重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Screen &amp;<span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//this指针隐式地传递给do_display()，从指向非常量的指针转换成指向常量的指针</span></span><br><span class="line">        do_display();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Screen &amp;<span class="title">display</span><span class="params">()</span><span class="comment">//重载函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        do_display();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_display</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;contents &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们在某个对象上调用display时，该对象是否是const决定了应该调用display哪个版本<h3 id="7-3-3-类类型"><a href="#7-3-3-类类型" class="headerlink" title="7.3.3 类类型"></a>7.3.3 类类型</h3></li>
<li>即使两个类的成员完全一样，也是不同的类型</li>
<li>类的声明<br>class Screen;<br>向程序中引入名字Screen并且指明它是一种类类型，但是我们不知道它里面有什么。<br>对于一个类来说，我们必须定义它之后再去创建它的对象，不然编译器不知道给你这个对象分配多少内存。<br>得到一个结论，一个类的成员类型不能是它自己，但是可以是它的指针或者引用。</li>
</ul>
<h3 id="7-3-4-友元再探"><a href="#7-3-4-友元再探" class="headerlink" title="7.3.4 友元再探"></a>7.3.4 友元再探</h3><ul>
<li>友元函数能定义在类的内部，这样的函数是隐式内联的</li>
<li>友元关系不存在传递性</li>
</ul>
<ul>
<li><p>类之间的友元</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>;</span>    </span><br><span class="line">    <span class="comment">//Window_mgr可以访问Screen所有成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>令成员函数成为友元<br>这个之前引出友元概念的时候就介绍了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Window_mgr::clear();    </span><br><span class="line">    <span class="comment">//这里是跟人家的成员函数做朋友</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Screen类要把Window_mgr类的clear()设为友元<br>   声明<strong><strong>____</strong></strong>定义<strong><strong><strong>_</strong></strong></strong>声明<br> 定义 <strong><strong><strong><strong><strong><strong>__</strong></strong></strong></strong></strong></strong> 友元声明、定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>;</span><span class="comment">//1.声明Screen</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 定义Window_mgr类，其中声明clear函数，但不定义它</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ScreenIndex = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Screen&gt;::size_type;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Screen&gt; screens;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.定义Screen，包括对clear的友元声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Window_mgr::clear(ScreenIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4 定义clear</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Window_mgr::clear(ScreenIndex i)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (i &gt;= screens.size()) <span class="keyword">return</span>;    <span class="comment">// judge for out_of_range.</span></span><br><span class="line">    Screen &amp;s = screens[i];</span><br><span class="line">    s.contents = <span class="built_in">std</span>::<span class="built_in">string</span>(s.height * s.width, <span class="string">' '</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="7-4-1-名字查找与定义域"><a href="#7-4-1-名字查找与定义域" class="headerlink" title="7.4.1 名字查找与定义域"></a>7.4.1 名字查找与定义域</h3><ul>
<li>类的定义分两步处理：编译器处理完类中的全部声明后才会处理成员函数的定义。遇到声明，都是去看本作用块中到此为止以前部分。</li>
<li>对于成员函数：成员函数体直到整个类可见后才会被处理，所以它能使用类中定义的任何名字<h4 id="用于类成员声明的名字查找"><a href="#用于类成员声明的名字查找" class="headerlink" title="用于类成员声明的名字查找"></a>用于类成员声明的名字查找</h4></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="built_in">string</span> bal = <span class="string">"a"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accout</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span><span class="comment">//使用的是外层的Money，**因为编译器只考虑Account中在实验Money前出现的声明**</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bal;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Money bal = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> Money; <span class="comment">//这样不行的，重新定义类型不能覆盖，是错误的行为</span></span><br><span class="line">    <span class="comment">//但是编译器并不会报错，所以要自己小心</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>总结<br>查找本区域中；找不到找外围作用域中；当成员定义在类的外部时，名字查找的第三步要考虑成员出现之前的全局作用域</li>
</ul>
<h4 id="Exercise-7-35"><a href="#Exercise-7-35" class="headerlink" title="Exercise 7.35"></a>Exercise 7.35</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span> Type;</span><br><span class="line"><span class="function">Type <span class="title">initVal</span><span class="params">()</span></span>; <span class="comment">// use `string`</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exercise</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> Type;</span><br><span class="line">    <span class="function">Type <span class="title">setVal</span><span class="params">(Type)</span></span>; <span class="comment">// use `double`</span></span><br><span class="line">    <span class="function">Type <span class="title">initVal</span><span class="params">()</span></span>; <span class="comment">// use `double`</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Type Exercise::setVal(Type parm) &#123;  <span class="comment">// first is `string`, second is `double`</span></span><br><span class="line">    val = parm + initVal();     <span class="comment">// Exercise::initVal()</span></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fixed</p>
<p>changed<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type Exercise::setVal(Type parm) &#123;</span><br><span class="line">    val = parm + initVal();</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>to</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exercise::Type Exercise::setVal(Type parm) &#123;</span><br><span class="line">    val = parm + initVal();</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>and <code>Exercise::initVal()</code> should be defined.</p>
<h2 id="7-5-构造函数再探"><a href="#7-5-构造函数再探" class="headerlink" title="7.5 构造函数再探"></a>7.5 构造函数再探</h2><h3 id="7-5-1-构造函数初始化列表"><a href="#7-5-1-构造函数初始化列表" class="headerlink" title="7.5.1 构造函数初始化列表"></a>7.5.1 构造函数初始化列表</h3><ul>
<li>初始化和赋值区别，前者直接初始化数据成员，后者则先初始化再赋值。建议使用构造函数初始值</li>
<li>成员的初始化顺序与它们在类定义中的出现顺序一致，而与初始化列表无关</li>
<li>默认实参和构造函数<br>通常，我们说默认构造函数是没有参数的，但我们也可以这么干：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data(<span class="built_in">string</span> s = <span class="string">""</span>) : bookNo(s)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>你可能觉得这个函数是一个普通的构造函数，但是，其实它是这个类的默认构造函数，它用到了默认实参，这么写的好处是，你可以不传参数，也能调用（不就相当于默认构造函数了吗），你不传参数的时候，它就用空字符串s去初始化bookNo，(类比下默认参数的情况)传的话就按照传的来，一式两用，还是很不错的。</p>
<ul>
<li>如果一个构造函数为所以的参数都提供了默认实参，则它实际上也定义了默认构造函数<h3 id="7-5-2-委托构造函数"><a href="#7-5-2-委托构造函数" class="headerlink" title="7.5.2 委托构造函数"></a>7.5.2 委托构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//这是函数一，是一个普通的构造函数</span></span><br><span class="line">    Sales_data(<span class="built_in">string</span> s, <span class="keyword">unsigned</span> cnt, <span class="keyword">double</span> price) : bookNo(s), units_sold(cnt), revenue(cnt*price)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接下来就是各种偷懒方法了，注意看</span></span><br><span class="line">    Sales_data(): Sales_data(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>)&#123;&#125; <span class="comment">//函数二是默认构造函数，委托函数一帮忙初始化，也可以认为是调用了函数一</span></span><br><span class="line">    Sales_data(<span class="built_in">string</span> s): Sales_data(s, <span class="number">0</span>, <span class="number">0</span>)&#123;&#125; <span class="comment">//函数三接受一个string参数，委托函数一帮忙初始化</span></span><br><span class="line">    Sales_data(istream &amp;is): Sales_data()</span><br><span class="line">    &#123;</span><br><span class="line">        read(is, *<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数四复杂些，它先委托函数二，就是默认构造函数，函数二去委托函数一，这些函数执行完成后，再执行函数四的函数体</span></span><br><span class="line">    <span class="comment">//调用read函数读取给定的istream</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="7-5-3-使用默认构造函数"><a href="#7-5-3-使用默认构造函数" class="headerlink" title="7.5.3 使用默认构造函数"></a>7.5.3 使用默认构造函数</h3><p><code>Sales_data obj; //注意不要加括号啊，加了括号就成了函数声明了.本意是想定义一个使用默认构造函数进行初始化的对象</code></p>
<h3 id="7-5-4-隐式的类类型转换"><a href="#7-5-4-隐式的类类型转换" class="headerlink" title="7.5.4 隐式的类类型转换"></a>7.5.4 隐式的类类型转换</h3><ul>
<li>如果构造函数只接受一个实参，那它实际上定义了一种隐式转换机制，什么意思呢，以Sales_data为例，该类有一个只接受一个string的构造函数，所以啊，我们可以把string转换为Sales_data类的对象：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sales_data b;</span><br><span class="line"><span class="built_in">string</span> a = <span class="string">"1"</span>;</span><br><span class="line">b.combine(a); <span class="comment">//这里a被转换为Sales_data对象，编译器创建了一个临时对象</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这种只带一个参数的构造函数，我们也把它称为转换构造函数。</p>
<p>但是我们只允许一步类类型转换，举个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">item.combine(<span class="string">"1"</span>);</span><br><span class="line"><span class="comment">//这样是错的，因为字符串常量到string是一步，string到类对象时一步，两步不行的</span></span><br><span class="line"><span class="comment">//不过我们可以用显式地写</span></span><br><span class="line">item.combine(<span class="built_in">string</span>(<span class="string">"1"</span>));</span><br><span class="line">item.combine(Sales_data(<span class="string">"1"</span>))</span><br><span class="line"><span class="comment">//总之，隐式的只能帮你一步</span></span><br></pre></td></tr></table></figure></p>
<h2 id="7-6-类的静态成员"><a href="#7-6-类的静态成员" class="headerlink" title="7.6 类的静态成员"></a>7.6 类的静态成员</h2><ul>
<li>因为静态成员函数不与任何对象绑定，所以没有this指针，不能声明为const的。</li>
<li>在类外部定义静态成员时，不能重复static关键字，该关键字只能出现在类内部的声明语句。在类内部不要定义、初始化静态成员</li>
<li>我们来定义一个在类内已经声明的static成员：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Account::interestRate = initRate();</span><br><span class="line"><span class="comment">//为什么不用在initRate函数前面加Account::呢</span></span><br><span class="line"><span class="comment">//因为从类名开始，剩下的部分都处于类的作用域之内了。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="静态成员能用于某些场景，而普通成员不能"><a href="#静态成员能用于某些场景，而普通成员不能" class="headerlink" title="静态成员能用于某些场景，而普通成员不能"></a>静态成员能用于某些场景，而普通成员不能</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> Bar m1; <span class="comment">//这个逆天吧，可以自己的类型;静态成员可以是不完全类型</span></span><br><span class="line">        statuc <span class="keyword">int</span> &amp;m2; <span class="comment">//逆天吧，未初始化的引用；</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主要是因为，静态成员一般在外面定义初始化，所以，在类内可以是不完全类型，胡作非为。</p>
<p>还有一个区别是，静态成员可以作为默认实参，666<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">clear</span><span class="params">(<span class="keyword">char</span> = bkground)</span></span>; <span class="comment">//666</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> bkground; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>非静态数据成员不能作为默认实参，因为它是属于对象的，你用对象的值去作为默认实参，结果是无法真正提供一个对象来获取成员的值，会引发错误。</p>
<h1 id="第9章-顺序容器"><a href="#第9章-顺序容器" class="headerlink" title="第9章 顺序容器"></a>第9章 顺序容器</h1><h2 id="9-1-顺序容器概述"><a href="#9-1-顺序容器概述" class="headerlink" title="9.1 顺序容器概述"></a>9.1 顺序容器概述</h2><ul>
<li>vector、deque、list（双向链表）、<br>forward_list、array、 string </li>
<li>list、forward_list都没有size操作</li>
<li>使用原则<blockquote>
<p>除非有很好的理由选择其他，否则选择vector<br>要随机访问，选择deque或vector，要中间插入或删除元素，用list或forward_list<br>既要随机访问，又需要中间插入，看哪个用的多</p>
</blockquote>
</li>
<li>假设noDefault是一个没有默认构造函数的类型，则<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;noDefault&gt; v1(<span class="number">10</span>, init);<span class="comment">//正确</span></span><br><span class="line"><span class="built_in">vector</span>&lt;noDefault&gt; v1(<span class="number">10</span>);<span class="comment">//错误，必须提供一个元素出</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="9-2-1-迭代器"><a href="#9-2-1-迭代器" class="headerlink" title="9.2.1 迭代器"></a>9.2.1 迭代器</h3><ul>
<li>forward_list不支持–运算符</li>
<li>双向链表的两个迭代器不能用&lt;、&lt;=等比较，因为节点不一定连续<h3 id="9-2-2-容器类型成员"><a href="#9-2-2-容器类型成员" class="headerlink" title="9.2.2 容器类型成员"></a>9.2.2 容器类型成员</h3></li>
<li>的size函数返回的是一个xx::size_type配套类型，这些配套类型体现了标准库类型与机器无关的特性。索引下标也是xx::size_type</li>
<li><h3 id="9-2-3-begin和end成员"><a href="#9-2-3-begin和end成员" class="headerlink" title="9.2.3 begin和end成员"></a>9.2.3 begin和end成员</h3></li>
<li>begin end 不以c开头的都是被重载过的</li>
<li>auto it7 = a.begin();//仅当a是const时，it7是const_iterator</li>
</ul>
<h3 id="9-2-4-容器定义和初始化"><a href="#9-2-4-容器定义和初始化" class="headerlink" title="9.2.4 容器定义和初始化"></a>9.2.4 容器定义和初始化</h3><ul>
<li>C c = {a, b, c,…} 任何遗漏的元素都进行值初始化</li>
<li>C c(b, e); array不适用</li>
<li>顺序容器（array除外）还提供另一个构造函数，接受一个容器大小的和一个可选的元素初始值。如果不提供元素初始值则标准库会创建一个值初始化器——内置类型或具有默认构造函数就能自设初始值</li>
<li><p>内置数组不能拷贝或赋值，array可以</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> digs[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cpy[<span class="number">10</span>] = digs;<span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; digits = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//注意要同时指定类型和大小</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; copy = digs;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>array不支持的地方：(迭代器1，迭代器2)初始化，assign(assign不支持关联容器、array)、insert（push_back）、resize</p>
</li>
<li>只有顺序容器的构造函数才接受大小参数，关联容器不支持</li>
</ul>
<h2 id="9-2-5-assign和swap"><a href="#9-2-5-assign和swap" class="headerlink" title="9.2.5 assign和swap"></a>9.2.5 assign和swap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names.assign(oldstyle.cbegin(),oldstyle.cend())</span><br><span class="line">slist1.assign(10,&quot;Hi&quot;);//assign的两个版本</span><br></pre></td></tr></table></figure>
<ul>
<li>赋值操作导致左边容器内部的迭代器、引用、指针失效</li>
<li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec1(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec2(<span class="number">24</span>);</span><br><span class="line">swap(vec1,vec2);<span class="comment">//交换两个相同类型容器的内容，元素不移动，只是交换了两个容器的内部结构，因此可以在常数时间内完成迭代器、引用、指针失效。 array用swap会真正交换元素，时间正比于元素个数，迭代器、引用、指针所绑定的元素不变</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="9-2-6-容器大小操作"><a href="#9-2-6-容器大小操作" class="headerlink" title="9.2.6 容器大小操作"></a>9.2.6 容器大小操作</h3><h3 id="9-2-6-关系运算符（-gt-lt-gt-lt-）"><a href="#9-2-6-关系运算符（-gt-lt-gt-lt-）" class="headerlink" title="9.2.6 关系运算符（&gt; &lt; &gt;= &lt;= ==）"></a>9.2.6 关系运算符（&gt; &lt; &gt;= &lt;= ==）</h3><ul>
<li>除了<strong>无序关联容器</strong>关系运算符都支持比较， 类似string</li>
</ul>
<h2 id="9-3-顺序容器操作"><a href="#9-3-顺序容器操作" class="headerlink" title="9.3 顺序容器操作"></a>9.3 顺序容器操作</h2><h3 id="9-3-1-向顺序容器添加元素"><a href="#9-3-1-向顺序容器添加元素" class="headerlink" title="9.3.1 向顺序容器添加元素"></a>9.3.1 向顺序容器添加元素</h3><ul>
<li>c.insert(p,t)<br>c.emplace(p,args)<br>在迭代器p指向的元素之前创建一个值为t或由agrs创建的元素(把参数传递给容器的元素类型的构造函数)，返回指向新添加的元素的迭代器</li>
<li>c.insert(c.end(),10,”Anna”);//在末尾插入</li>
<li>向vector、string、deque插入元素后（deque首尾插入、list、forward_list没关系）会使得插入元素后面的指向容器的迭代器、引用、指针失效。若扩容了原先的都会失效</li>
<li>容器元素是原对象值的拷贝</li>
<li>vector、string不支持push_front和emplace_front，deque支持 但是可以用insert实现对应的功能<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">double_and_insert</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">int</span> some_val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> mid = [&amp;]&#123; <span class="keyword">return</span> v.begin() + v.size() / <span class="number">2</span>; &#125;;<span class="comment">//lamda表达式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> curr = v.begin(); curr != mid(); ++curr)</span><br><span class="line">        <span class="keyword">if</span> (*curr == some_val)</span><br><span class="line">            ++(curr = v.insert(curr, <span class="number">2</span> * some_val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="9-3-2-访问元素"><a href="#9-3-2-访问元素" class="headerlink" title="9.3.2 访问元素"></a>9.3.2 访问元素</h3><ul>
<li>c.back(),c.front() ,返回首尾元素的引用(c[n],c.at(n)也是引用)</li>
<li>c.at()：at会进行下标越界检查，越界时抛出out_of_range异常。因此更安全<h3 id="9-3-3-删除"><a href="#9-3-3-删除" class="headerlink" title="9.3.3 删除"></a>9.3.3 删除</h3></li>
<li>c.pop_back()：forward_list不支持。返回void<br>c.pop_front()：vector,string不支持。返回void</li>
<li>c.erase(p)：删除迭代器p指定的元素，返回被删除元素后元素的迭代器。若p是尾元素，则返回尾后迭代器；若p是尾后迭代器，结果未定义；​</li>
<li>c.erase(b,e)：删除迭代器b、e范围间的元素，e不会删除。返回最后一个被删除元素后一个元素的迭代器。调用结束后，b == e​</li>
<li>c.clear()：删除所有<br>返回void</li>
<li>除了deque删除首尾元素，指向vectorhe和string中删除点之后的迭代器、引用和指针都会失效，list、forward_list没关系</li>
<li>vector和string不支持push_front()、pop_front()</li>
</ul>
<h3 id="9-3-4-forward-list操作"><a href="#9-3-4-forward-list操作" class="headerlink" title="9.3.4 forward_list操作"></a>9.3.4 forward_list操作</h3><ul>
<li><p>插入 在迭代器p之后的位置插入元素，返回指向<strong>最后一个插入元素</strong>的迭代器。注意其他顺序容器插入后是返回<strong>指向第一个新添加</strong>的元素的迭代器，且是往迭代器之前插</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lis.before_begin()<span class="comment">//首前迭代器</span></span><br><span class="line">lis.insert_after(p,t)</span><br><span class="line">lis.insert_after(p,n,t)</span><br><span class="line">lis.insert_after(p,b,e)</span><br><span class="line">lis.insert_after(p,il)</span><br><span class="line">lis.emplace_after(p,args)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除：返回被删除之后元素的迭代器。如果p指向尾元素或是一个尾后迭代器，结果未定义.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lis.erase_after(p)：删除迭代器p之后的元素</span><br><span class="line">lst.erase_after(b,e)：不包含迭代器b指向的元素</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="9-5-2-改变string的其他方法"><a href="#9-5-2-改变string的其他方法" class="headerlink" title="9.5.2 改变string的其他方法"></a>9.5.2 改变string的其他方法</h3><ul>
<li>s.insert(11,”fifth”)</li>
<li>s.replace(11,3,”fifth”)</li>
<li>s.erase(11,3)  </li>
</ul>
<h3 id="9-5-3-string搜索操作"><a href="#9-5-3-string搜索操作" class="headerlink" title="9.5.3 string搜索操作"></a>9.5.3 string搜索操作</h3><ul>
<li>搜索的返回值string::size_type  搜索失败返回string::npos<h3 id="compare函数"><a href="#compare函数" class="headerlink" title="compare函数"></a>compare函数</h3></li>
<li>s.compare(s2) <h3 id="9-5-5-数值转换"><a href="#9-5-5-数值转换" class="headerlink" title="9.5.5 数值转换"></a>9.5.5 数值转换</h3></li>
<li>to_string(i) // 整数i转换为字符表示形式</li>
<li>stod(s) //字符串s转换为浮点数  第一个字符可以是+—数字</li>
<li>stoi(s) //转为整型</li>
</ul>
<h2 id="9-6-容器适配器"><a href="#9-6-容器适配器" class="headerlink" title="9.6 容器适配器"></a>9.6 容器适配器</h2><ul>
<li>stack queue基于deque实现的，priority_queue是在vector上实现的</li>
</ul>
<h1 id="第10章-泛型算法"><a href="#第10章-泛型算法" class="headerlink" title="第10章 泛型算法"></a>第10章 泛型算法</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><ul>
<li><p>find<br>vector 的 find：<br>  <code>vector&lt;int&gt;::iterator it = find(vec.begin(), vec.end(), 6);</code> 查找6,找到返回第一个的迭代器，找不到返回尾后迭代器<br>数组的find：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> * p;</span><br><span class="line">    </span><br><span class="line">    p = find (myints, myints+<span class="number">4</span>, <span class="number">30</span>);  <span class="comment">//返回查找到的元素的物理地址</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">if</span> (p != myints+<span class="number">4</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element found in myints: "</span> &lt;&lt; *p &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Element not found in myints\n"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型算法本身不会执行容器的操作，只会运行与迭代器之上，执行迭代器的操作。算法永远不会改变底层容器的大小。</p>
</li>
<li>标准库定义了特殊的迭代器，称为插入器，当给这类迭代器赋值时，他们会在底层的容器上执行插入操作。即算法执行迭代器，迭代器完成向容器添加元素的效果，但算法自身永远不会做这样的操作。<h2 id="10-2-初识泛型算法"><a href="#10-2-初识泛型算法" class="headerlink" title="10.2 初识泛型算法"></a>10.2 初识泛型算法</h2><h3 id="10-2-1-只读算法"><a href="#10-2-1-只读算法" class="headerlink" title="10.2.1 只读算法"></a>10.2.1 只读算法</h3><h4 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h4>对元素求和<code>int sum = accumulate(vec.cbegin(), vec.cend(), 0);</code>第三个参数是和的初始值<br><code>string sum = accumulate(vec.cbegin(), vec.cend(), string(&quot;&quot;));</code>  accumulate第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sum = accumulate(vec.cbegin(), vec.cend(), <span class="string">""</span>);</span><br><span class="line"><span class="comment">//错误，如果传递一个字符串字面值，用于保存和的对象类型是const char*，这种类型上没有定义+运算符</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="操作两个序列的算法-equal"><a href="#操作两个序列的算法-equal" class="headerlink" title="操作两个序列的算法 equal"></a>操作两个序列的算法 equal</h4><ul>
<li>equal(vec1.cbegin(), vec1.cend(), vec2.cbegin());//接收三个迭代器，前两个（与以往一样）表示第一个序列中的元素范围，第三个表示第二个序列的首元素</li>
<li>元素类型也不必一样，只要我们能用==来比较两个元素类型（其实视情况而定，c风格的字符串比较比较的是字符串的指针。但是呢，对于相同的字符串，编译器会把他们存在相同的地址里面，详见P339 ex10.5）</li>
<li>这些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长</li>
</ul>
<h1 id="第11章-关联容器"><a href="#第11章-关联容器" class="headerlink" title="第11章 关联容器"></a>第11章 关联容器</h1><h2 id="11-1-使用关联容器"><a href="#11-1-使用关联容器" class="headerlink" title="11.1 使用关联容器"></a>11.1 使用关联容器</h2><ul>
<li>map</li>
<li>set</li>
<li>multimap</li>
<li><p>multiset</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求最大的k个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; nums.size()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>,less&lt;<span class="keyword">int</span>&gt;&gt; largestK;<span class="comment">//小顶堆（根小于等于儿子），less&lt;int&gt;是默认的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>unordered_map</p>
</li>
<li>unordered_set</li>
<li>unordered_multimap</li>
<li>unordered_multiset</li>
<li>map元素是pair类型的对象，first, second两个数据成员</li>
<li><p>set中 exclude.find(word) 调用返回迭代器，如果给定关键字在set中，迭代器指向该关键字。否则，find返回尾后迭代器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1,T2&gt; p <span class="comment">//数据成员值初始化</span></span><br><span class="line">pair&lt;T1,T2&gt; p = p2</span><br><span class="line">pair&lt;T1,T2&gt; p(v1,v2)</span><br><span class="line">pair&lt;T1,T2&gt; p&#123;v1,v2&#125;</span><br><span class="line"><span class="comment">//与上面等价</span></span><br><span class="line">makepair(v1,v2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>pair比较大小，先比较第一个的</p>
</li>
</ul>
<h2 id="11-3-关联容器操作"><a href="#11-3-关联容器操作" class="headerlink" title="11.3 关联容器操作"></a>11.3 关联容器操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">key_type：关键字类型</span><br><span class="line">mapped_type (仅<span class="built_in">map</span>)：关键字关联的类型（即值的类型）</span><br><span class="line">value_type</span><br><span class="line">    <span class="built_in">map</span>：pair&lt;<span class="keyword">const</span> k,v&gt;，关键字为<span class="keyword">const</span>意味着不能修改</span><br><span class="line">    <span class="built_in">set</span>：与key_type相同​</span><br></pre></td></tr></table></figure>
<h3 id="11-3-1-关联容器迭代器"><a href="#11-3-1-关联容器迭代器" class="headerlink" title="11.3.1 关联容器迭代器"></a>11.3.1 关联容器迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator mpIt;</span><br><span class="line"><span class="keyword">for</span>(mpIt = mp.begin(); mpIt != mp.end(); mpIt++);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mpIt-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; mpIt-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个map的value_type是一个pair，我们可以改变pair的值，但不能改变关键字成员的值</li>
<li>set的迭代器都是const的。不能修改元素的值</li>
<li>添加单一元素的insert和emplace版本返回一个pair，pair的first是一个迭代器，指向具有关键字的元素；second成员是一个bool值，告诉我们插入成功还是已经存在于容器中。（false插入失败，已经有值）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = word_count.insert(&#123;word, <span class="number">1</span>&#125;); <span class="comment">//不在里面，值就是1</span></span><br><span class="line">    <span class="keyword">if</span>(!ret.second)&#123; ++( (ret.first)-&gt;second ); &#125; <span class="comment">//已在里面，递增计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="11-3-3-删除元素"><a href="#11-3-3-删除元素" class="headerlink" title="11.3.3 删除元素"></a>11.3.3 删除元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.eraser(k)	从c中删除每个关键字为k的元素，返回一个size_type值，即删除元素的数量</span><br><span class="line">c.eraser(p)	从c中删除迭代器p指定的元素（必须存在），返回p之后元素的迭代器</span><br><span class="line">c.eraser(b, e)	删除迭代器b和e之间的元素，返回e</span><br></pre></td></tr></table></figure>
<h3 id="11-3-3-map的下标操作"><a href="#11-3-3-map的下标操作" class="headerlink" title="11.3.3 map的下标操作"></a>11.3.3 map的下标操作</h3><ul>
<li>只有map有下标，set类型没有是因为人家就一个键，没有值，下标谁去，multimap没有是因为可能有多个值跟键相关。有两种方式c[k]和c.at(k)，都是有就返回值（类型为mapped_type），没有就插入</li>
<li>C++ map中key值存在情况判定<blockquote>
<p>count函数<br>count函数用于统计key值在map中出现的次数，map的key不允许重复，因此如果key存在返回1，不存在返回0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (testMap.count(key) == 0)</span><br><span class="line">    cout &lt;&lt; &quot;no this key&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="11-3-5-访问元素"><a href="#11-3-5-访问元素" class="headerlink" title="11.3.5 访问元素"></a>11.3.5 访问元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">iset.find(<span class="number">1</span>); <span class="comment">//返回一个指向1的迭代器</span></span><br><span class="line">iset.find(<span class="number">-1</span>); <span class="comment">//返回一个指向iset.end()的迭代器</span></span><br><span class="line">iset.count(<span class="number">1</span>); <span class="comment">//返回1，返回该元素的数量</span></span><br><span class="line">iset.count(<span class="number">11</span>); <span class="comment">//返回0</span></span><br><span class="line"></span><br><span class="line">iset.lower_bound(<span class="number">2</span>); <span class="comment">//返回一个迭代器指向第一个不小于2的元素，就是2</span></span><br><span class="line">iset.upper_bound(<span class="number">2</span>); <span class="comment">//返回一个指向第一个大于2的元素迭代器，3</span></span><br><span class="line">iset.equal_range(<span class="number">2</span>); <span class="comment">//返回一个迭代器pair，表示键等于2的元素范围，没有就返回一对end</span></span><br></pre></td></tr></table></figure>
<h4 id="set的查找"><a href="#set的查找" class="headerlink" title="set的查找"></a>set的查找</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">## 11.3.6 单词转换的map</span><br><span class="line">```cpp</span><br><span class="line">作者：苍井玛利亚</span><br><span class="line">链接：https://www.nowcoder.com/discuss/20296</span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line">//函数word_transform</span><br><span class="line">void word_transform(ifstream &amp;map_file, ifstream &amp;input)</span><br><span class="line">&#123;</span><br><span class="line">    auto trans_map = buildMap(mapfile); </span><br><span class="line">    string text; //保存输入中的每一行</span><br><span class="line">    while(getline(input, text))</span><br><span class="line">    &#123;</span><br><span class="line">        istringstream stream(text); //读取每个单词,忽略空格</span><br><span class="line">        string word;</span><br><span class="line">        bool firstword = true; //控制是否打印空格</span><br><span class="line">        while(stream &gt;&gt; word)</span><br><span class="line">        &#123;</span><br><span class="line">            if(firstword)&#123;firstword = false;&#125;</span><br><span class="line">            else&#123;cout &lt;&lt; &quot; &quot;;&#125;</span><br><span class="line">            cout &lt;&lt; transformm(word, trans_map); //打印输出</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl; //完成一行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数buildMap</span><br><span class="line">map&lt;string, string&gt; buildMap(ifstream &amp;map_file)</span><br><span class="line">&#123;</span><br><span class="line">    map&lt;string, string&gt; trans_map;</span><br><span class="line">    string key;</span><br><span class="line">    string value;</span><br><span class="line">    while(map_file &gt;&gt; key &amp;&amp; getline(map_file, value)) //取一行，分别作为键值</span><br><span class="line">    &#123;</span><br><span class="line">        if( value.size()&gt;1 ) //确保有转换内容</span><br><span class="line">        &#123;</span><br><span class="line">            trans_map[key] = value.substr(1); //跳过单词和转换内容之间的空格，因为getline不会跳过前导空格</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            throw runtime_error(&quot;no rule for &quot; + key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return trans_map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数transform</span><br><span class="line">const string&amp; transform(const string &amp;s, const map&lt;string, string&gt; &amp;m)</span><br><span class="line">&#123;</span><br><span class="line">    auto map_it = m.find(s);</span><br><span class="line">    if(map_it != m.cend())</span><br><span class="line">    &#123;</span><br><span class="line">        return map_it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>trans_map[key] = value.substr(1)</code>和<code>trans_map.insert({ key, value.substr(1) })</code>区别？<br>  如果出现多次，下标法插入最后一个，insert插入第一个</li>
</ul>
<h2 id="11-4无序容器"><a href="#11-4无序容器" class="headerlink" title="11.4无序容器"></a>11.4无序容器</h2><ul>
<li>用hash来种植元素</li>
</ul>
<h1 id="第12-章-动态内存"><a href="#第12-章-动态内存" class="headerlink" title="第12 章 动态内存"></a>第12 章 动态内存</h1><h2 id="12-1-动态内存与智能指针"><a href="#12-1-动态内存与智能指针" class="headerlink" title="12.1 动态内存与智能指针"></a>12.1 动态内存与智能指针</h2><ul>
<li>通过不同方式定义的变量类型在内存中的存储位置也不同，分以下三种情况：<ul>
<li>静态内存：保存局部static对象、类static数据成员、定义在任何函数之外的变量</li>
<li>栈内存：保存定义在函数内的非static对象</li>
<li>堆：存储动态分配的对象，当动态对象不再使用时，我们必须显式地销毁它们</li>
</ul>
</li>
<li>智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。两种智能指针管理底层指针的方式不同：<ul>
<li>shared_ptr允许多个指针指向同一个对象</li>
<li>unique_ptr独占所指向的对象</li>
<li>weak_ptr，弱引用，指向shared_ptr所管理的对象<br>以上三种类型都定义在memory头文件中。</li>
</ul>
</li>
</ul>
<h3 id="12-1-1-shared-ptr类"><a href="#12-1-1-shared-ptr类" class="headerlink" title="12.1.1 shared_ptr类"></a>12.1.1 shared_ptr类</h3><ul>
<li><p>类似vector，<strong>智能指针也是模板</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span> p1; <span class="comment">//shared_ptr, 指向string</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&gt; p2; <span class="comment">//shared_ptr, 指向list</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>默认初始化的智能指针中保存着一个空指针。 智能指针的使用方式与普通指针类似，解引用一个智能指针返回它指向的对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p1 &amp;&amp; p1-&gt;empty()) <span class="comment">//如果指针本身不为空（有所指对象），且指针所指对象为空</span></span><br><span class="line">&#123;</span><br><span class="line">    *p1 = <span class="string">"hi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="make-shared"><a href="#make-shared" class="headerlink" title="make_shared()"></a>make_shared()</h4><ul>
<li><p>传递的参数必须能用来初始化所指对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">//指向int42的share_ptr</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p2 = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">5</span>,<span class="string">'9'</span>); <span class="comment">//指向"99999"的share_ptr</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不传递参数时，对象就会进行值初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p0 = make_shared&lt;<span class="keyword">int</span>&gt;(); <span class="comment">//指向值初始化的int0的share_ptr</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="shared-ptr的拷贝与赋值"><a href="#shared-ptr的拷贝与赋值" class="headerlink" title="shared_ptr的拷贝与赋值"></a>shared_ptr的拷贝与赋值</h4><ul>
<li><p>当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">//p指向的对象只有p一个引用者</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>; <span class="comment">//p和q指向相同对象，此对象有两个引用者</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用计数： 无论何时我们拷贝一个shared_ptr，都会递增计数器，举些不那么明显的拷贝例子</p>
<ul>
<li>用一个shared_ptr初始化另一个shared_ptr</li>
<li>将它作为参数传递给一个函数</li>
<li>作为函数的返回值</li>
</ul>
</li>
<li>递减计数器：<ul>
<li>给shared_ptr赋予一个新值</li>
<li>shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域）</li>
</ul>
</li>
<li><p>一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = make_shared(<span class="number">42</span>); <span class="comment">//r指向的int只有一个引用者</span></span><br><span class="line">r = q; </span><br><span class="line"><span class="comment">//1：给r赋新值，让它指向新地址；2：递增q指向对象的引用计数；</span></span><br><span class="line"><span class="comment">//3：递减r原来指向的对象的引用计数；4：r原来指向的对象已没有引用者，会自动释放</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>程序使用动态内存出于以下三种原因之一：</p>
<ul>
<li>程序不知道自己要使用多少对象（比如容器类）</li>
<li>程序不知道所需对象的准确类型（15章再学）</li>
<li>程序需要在多个对象间共享数据（接下来介绍）</li>
</ul>
</li>
<li><p>对const 重载，返回类型、this都加</p>
<h3 id="12-1-2-直接管理内存"><a href="#12-1-2-直接管理内存" class="headerlink" title="12.1.2 直接管理内存"></a>12.1.2 直接管理内存</h3></li>
<li><p>动态分配内存的对象是默认初始化的，这意味着内置类型或组合类型的对象的值是未定义的，而类类型对象将用默认构造函数进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps1 = <span class="keyword">new</span> <span class="built_in">string</span>; <span class="comment">//默认初始化为空string </span></span><br><span class="line"><span class="built_in">string</span> *ps2 = <span class="keyword">new</span> <span class="built_in">string</span>(); <span class="comment">//值初始化为空string</span></span><br><span class="line"><span class="keyword">int</span> *pi1 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//默认初始化：*p1未定义 </span></span><br><span class="line"><span class="keyword">int</span> *pi2 = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">//值初始化为0，pi2指向的内存值为0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>神器auto在这种初始化方式下有所限制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> class(T); <span class="comment">//p指向一个与T类型相同的对象，该对象用T进行初始化</span></span><br><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> class&#123;a, b, c&#125;; <span class="comment">//这样不行，括号中只能有单个初始化器，</span></span><br><span class="line"><span class="comment">//因为你这样让auto无法判断p2是什么类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>动态分配的const对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">24</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *pcs = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in">string</span>; <span class="comment">//和其他const对象一样，一个动态分配的const必须被初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内存耗尽:在C++中，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常，不过，我们可以阻止它抛出异常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// 如果失败就会抛出异常</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span>; <span class="comment">//分配失败只会返回一个空指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>释放动态内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">24</span>); </span><br><span class="line"><span class="keyword">delete</span> p1; <span class="comment">//分两步：销毁p1指向的对象，释放对应内存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>释放空指针合法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pi = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> pi;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//The p will convert to a bool , which means that the dynamic memory allocated has no chance to be freed. As a result, memory leakage will occur.</span></span><br></pre></td></tr></table></figure>
<h3 id="12-1-3-shared-ptr和new结合使用"><a href="#12-1-3-shared-ptr和new结合使用" class="headerlink" title="12.1.3 shared_ptr和new结合使用"></a>12.1.3 shared_ptr和new结合使用</h3><ul>
<li>智能指针的构造函数是explicit的（禁止隐式转换），所以必须使用直接初始化形式<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr p1(new int(24)); //我们知道这样是对的，直接初始化</span><br><span class="line"><span class="built_in">shared_ptr</span> p2 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">24</span>); <span class="comment">//错误，不能使用拷贝初始化，因为不能进行内置指针到只能指针间的隐式转换</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="不要混合使用普通指针和智能指针"><a href="#不要混合使用普通指针和智能指针" class="headerlink" title="不要混合使用普通指针和智能指针"></a>不要混合使用普通指针和智能指针</h4><p>错误例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="built_in">shared_ptr</span> ptr)</span></span>&#123;&#125;</span><br><span class="line">int *x(new int(24));</span><br><span class="line">process(<span class="built_in">shared_ptr</span>(x));<span class="comment">//调用结束时，所指向的对象也就是x被释放了</span></span><br><span class="line"><span class="keyword">int</span> j = *x; <span class="comment">//x是空悬指针</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>使用内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时被销毁<h4 id="也不要使用get初始化另一个智能指针或为智能指针赋值（也是不要混合使用普通指针和智能指针，赋值是推荐make-shared而不是new）"><a href="#也不要使用get初始化另一个智能指针或为智能指针赋值（也是不要混合使用普通指针和智能指针，赋值是推荐make-shared而不是new）" class="headerlink" title="也不要使用get初始化另一个智能指针或为智能指针赋值（也是不要混合使用普通指针和智能指针，赋值是推荐make_shared而不是new）"></a>也不要使用get初始化另一个智能指针或为智能指针赋值（也是不要混合使用普通指针和智能指针，赋值是推荐make_shared而不是new）</h4></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">shared_ptr p(new int(42));</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(p.get()); <span class="comment">//两个独立的智能指针指向相同的内存块（要出事情），此时形成的参数并不是对p的拷贝，而是一个独立的指针。改成shared_ptr(p)就没事情</span></span><br><span class="line">&#125; <span class="comment">//q指向的内存被销毁</span></span><br><span class="line"><span class="keyword">int</span> foo = *p; <span class="comment">//p是空悬指针，报错。</span></span><br></pre></td></tr></table></figure>
<h3 id="12-1-4-智能指针和异常"><a href="#12-1-4-智能指针和异常" class="headerlink" title="12.1.4 智能指针和异常"></a>12.1.4 智能指针和异常</h3><ul>
<li><p>使用智能指针的好处：即便代码出现没有catch到的异常，还是能保证内存的释放：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr sp(new int(42));</span><br><span class="line">    <span class="comment">//假设之后的代码出现了没有捕捉到的异常</span></span><br><span class="line">&#125; <span class="comment">//在函数结束时，shared_ptr还是会自动释放内存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用智能指针管理，并且定义一个函数（删除器）用来代替delete函数：<br>shared_ptr<t> p(q,d);//p接管了内置指针q所指向的对象的所有权。q必须能够转化为T*类型。p将使用可调用对象d</t></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connect</span><span class="params">(connect *p)</span></span>&#123; disconnetc(*p); &#125; <span class="comment">//定义了删除器（调用了一个函数）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connect c;</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span> <span class="title">p</span><span class="params">(&amp;c, end_connect)</span></span>; <span class="comment">//用p来管理c的内存</span></span><br><span class="line">&#125;<span class="comment">//退出后c就会被正确关闭销毁</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="12-1-5-unique-ptr"><a href="#12-1-5-unique-ptr" class="headerlink" title="12.1.5 unique_ptr"></a>12.1.5 unique_ptr</h3><ul>
<li>必须采用直接初始化形式。unique_ptr不支持普通的拷贝或赋值<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span> p1;</span><br><span class="line">unique_ptr pt(new int(42));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="c-11-新特性"><a href="#c-11-新特性" class="headerlink" title="c++ 11 新特性"></a>c++ 11 新特性</h1><ul>
<li>尾随返回类型 P233 ex7.5</li>
<li></li>
</ul>
<h1 id="华为机试"><a href="#华为机试" class="headerlink" title="华为机试"></a>华为机试</h1><h2 id="购物单"><a href="#购物单" class="headerlink" title="购物单"></a>购物单</h2><ul>
<li>有依赖的分组背包问题</li>
<li>set的使用</li>
<li>memeset 要加头文件#include <cstring></cstring></li>
</ul>
<h2 id="坐标移动"><a href="#坐标移动" class="headerlink" title="坐标移动"></a>坐标移动</h2><ul>
<li>string 迭代器与自增   *(itFront++) 先访问*itFront再让itFront加</li>
<li>isalnum(c) 字母或数字  isalpha(c)字母 isdigit(c) 数字 islower isupper</li>
<li>字符串常用操作取子串string str =“Hello”；<br>   str.substr(0,4)=“Hell”,0是起始位置，4是要复制的长度</li>
<li>s.substr(5); //只有一个数字5表示从下标为5开始一直到结尾</li>
<li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> ss = <span class="string">"aa"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ss.substr(<span class="number">2</span>);<span class="comment">//√</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ss.substr(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除最后一个 s.pop_back();<br>###</p>
</li>
<li>排序降序 #include<algorithm>  sort(a,a+20,greater<int>());//第三个参数可以不写 默认从小到大排序<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sort(a, a+n, cmp);</span><br><span class="line">cmp也可以自己写</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span><span class="comment">//要加static https://blog.csdn.net/u010982765/article/details/79021426</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.w &lt; b.w ) <span class="comment">//按照w的值进行的是：升序排列 ！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</int></algorithm></li>
</ul>
<p>vector的排序 sort(po.begin(), po.end(), cmp);</p>
<ul>
<li>string find<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left=<span class="number">0</span>,right=s.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            left=s.find_first_of(<span class="string">"aeiouAEIOU"</span>,left);<span class="comment">//从left位置开始 找到aeiouAEIOU里一个即可</span></span><br><span class="line">            right=s.find_last_of(<span class="string">"aeiouAEIOU"</span>,right);</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(s[left++],s[right--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">```  </span><br><span class="line">s.rfind(args)查找s中args最后一次出现的位置  </span><br><span class="line">s.find_last_of(args)查找s中args里面任何一个字符最后一次出现的位置  </span><br><span class="line">s.find_first_not_of  </span><br><span class="line">str1.find(str2,<span class="number">5</span>);<span class="comment">//   从str1的第5个字符开始查找str2,找不到返回-1</span></span><br><span class="line"></span><br><span class="line">- <span class="built_in">vector</span> 的 find：</span><br><span class="line">    `<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find(vec.begin(), vec.end(), <span class="number">6</span>);` 查找<span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 删除字符串中出现次数最少的字符</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>it2 = str.erase(it2);//it2是string迭代器，返回指向删除字符的后一字符位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">```cpp</span><br><span class="line">for (it = str.begin(); it &lt; str.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (*it == ch)</span><br><span class="line">        &#123;</span><br><span class="line">            str.erase(it);</span><br><span class="line">            it--;</span><br><span class="line">            /*</span><br><span class="line">            it--很重要，因为使用erase()删除it指向的字符后，后面的字符就移了过来，</span><br><span class="line">            it指向的位置就被后一个字符填充了，而for语句最后的it++，又使it向后移</span><br><span class="line">            了一个位置，所以就忽略掉了填充过来的这个字符。在这加上it--后就和for</span><br><span class="line">            语句的it++抵消了，使迭代器能够访问所有的字符。</span><br><span class="line">            */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>函数不要返回指向栈的内存地址，切记，是地址，别被吓的所有的函数内的变量都不敢返回，只要不是栈的内存地址，你尽管放心的返回。</p>
<h3 id="旋转数组返回最小值"><a href="#旋转数组返回最小值" class="headerlink" title="旋转数组返回最小值"></a>旋转数组返回最小值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;<span class="comment">//考虑只有一元素，如果是等于就会一直循环</span></span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt; nums[r]) <span class="keyword">break</span>;<span class="comment">//最左边小于最右边 直接返回最左边</span></span><br><span class="line">            mid = l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt;= nums[mid]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><ul>
<li>BFS的问题一般都会选用队列方式实现；</li>
<li><p>代码模板如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void BFS()</span><br><span class="line">&#123;</span><br><span class="line">    定义队列;</span><br><span class="line">    定义备忘录，用于记录已经访问的位置；</span><br><span class="line"></span><br><span class="line">    判断边界条件，是否能直接返回结果的。</span><br><span class="line"></span><br><span class="line">    将起始位置加入到队列中，同时更新备忘录。</span><br><span class="line"></span><br><span class="line">    while (队列不为空) &#123;</span><br><span class="line">        获取当前队列中的元素个数。</span><br><span class="line">        for (元素个数) &#123;</span><br><span class="line">            取出一个位置节点。</span><br><span class="line">            判断是否到达终点位置。</span><br><span class="line">            获取它对应的下一个所有的节点。</span><br><span class="line">            条件判断，过滤掉不符合条件的位置。</span><br><span class="line">            新位置重新加入队列。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二分查找<br>lower_bound(val):返回容器中第一个值【大于或等于】val的元素的iterator位置。<br>upper_bound(val): 返回容器中第一个值【大于】</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tronyy.github.io/archives/2019/09/27/Apollo×baidu公开课笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天洋行空">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天洋行空">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/27/Apollo×baidu公开课笔记/" itemprop="url">Apollo×baidu公开课笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-27T10:43:13+08:00">
                2019-09-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Driving/" itemprop="url" rel="index">
                    <span itemprop="name">Driving</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第二课：高精度地图"><a href="#第二课：高精度地图" class="headerlink" title="第二课：高精度地图"></a>第二课：高精度地图</h1><h2 id="高精度地图"><a href="#高精度地图" class="headerlink" title="高精度地图"></a>高精度地图</h2><ul>
<li>厘米级进度。交通灯、限速、路标等信息</li>
<li>搜集的信息与高精度题图匹配——预处理、坐标转换、数据融合——以便知道自己处于什么位置</li>
<li>高精度地图作用，传感器有距离限制，这种情况下由高精度地图提供位置。另一个好处减小传感器检测范围——集中检查感兴趣区域ROI，提高速度进度 减小计算资源。规划软件也需要 靠近中心线，帮助减少决策空间</li>
<li>Apollo高精度地图采用了OpenDRIVE格式，行业制图标准</li>
<li>高精度地图5个过程：数据采集（众包采集）、数据处理、目标检测、手动验证、地图发布</li>
</ul>
<h1 id="第三课-定位"><a href="#第三课-定位" class="headerlink" title="第三课 定位"></a>第三课 定位</h1><ul>
<li>GPS进度在1-3米，在信号不好的地方，可以达到数十米。转换坐标系、由传感器得到的标示与 在全局地图上的位置进行匹配<h3 id="GPS（GNSS）"><a href="#GPS（GNSS）" class="headerlink" title="GPS（GNSS）"></a>GPS（GNSS）</h3></li>
<li>三角定位（三个圆交点），GPS传送距离</li>
<li>gps 卫星、地面的控制站 监视和控制卫星、GPS接收器（手机上、汽车上）。每次至少接收4颗。时间乘以光速（原子钟）。  RTK纠错发给gps接收器。 gps缺点受遮挡物干扰、更新频率低<h3 id="惯性导航"><a href="#惯性导航" class="headerlink" title="惯性导航"></a>惯性导航</h3></li>
<li>三轴传感器测加速度。 螺旋仪。 IMU短时间内定位，频率高，短时间定位。要与gps结合。但是仍旧不精确 因为gps有些地形下失效<h3 id="激光雷达定位"><a href="#激光雷达定位" class="headerlink" title="激光雷达定位"></a>激光雷达定位</h3></li>
<li>点云匹配——迭代最近点法，点云旋转 减小误差，匹配，传感器得到的位置转化为全局</li>
<li>LiDAR：滤波算法；消除冗余，最小平方误差。 卡尔曼滤波，预测新位置，用传感器测量新位置纠正。优点稳健性，只要有高精度地图+传感器更正。难点 地图不可能保持最新<h3 id="图像定位"><a href="#图像定位" class="headerlink" title="图像定位"></a>图像定位</h3></li>
<li>粒子滤波（概率）。对车道线拍照。优点 图像数据容易得到。缺点：缺乏三维信息和对三维地图的依赖</li>
<li><h1 id="第四课-感知"><a href="#第四课-感知" class="headerlink" title="第四课 感知"></a>第四课 感知</h1></li>
<li>4个核心人物检测：找出位置，分类、跟踪、语义分割</li>
<li>分类器：接收输入，预处理（标准化，调大小、旋转）、提取特征</li>
<li>摄像头图像：RGB图像 </li>
<li>LiDAR图像：雷达发射，点云<br><img src="https://uploadfiles.nowcoder.com/compress/mw1000/images/20190925/5783209_1569396196472_CF4CCFB89DAD844675ED709E79CE8248" alt="image"></li>
<li>机器学习：使用数据。监督式学习、半监督、无监督。强化学习</li>
<li>神经网络：调整某些特征的权重，得到最终结果</li>
<li>反向传播</li>
<li>CNN：接收多维输入。标准神经网络的弄成一维，打破了图像中嵌入的空间信息。在整个图像上对一个过滤器进行卷积操作&gt; <blockquote>
<p>（什么是卷积：图像中不同数据窗口的数据和卷积核（一个滤波矩阵）作内积的操作叫做卷积。其计算过程又称为滤波（filter)，本质是提取图像不同频段的特征。）</p>
</blockquote>
</li>
<li>检测与分类：CNN中找出图像中对象的位置、定位，发给另一个CNN进行分类，或者直接一个CNN完成。R FastRCNN FasterRCNN ，YOLO SSD</li>
<li>跟踪：解决遮挡物、追踪可以保留身份。前后两帧中对象匹配。计算机视觉可以计算出复杂的图像特征，如局部二值模式和方向梯度直方图。连续帧中，两个障碍物之间的位置和速度</li>
<li>分割：确定汽车可行驶的位置。FCN，每一层都是卷积层。CNN最后输出比原图像小得多。为了分割图像，输出尺寸必须与原始图像的尺寸相匹配，中间输出进行上采用处理。  前半部分encoder对输入图像的特征进行了提取和编码。后半部分解码器对特征进行解码 用于输出。<blockquote>
<p>上采样可以用来进行图像放大，多采用内插方法，即在原有图像像素的基础上在像素点之间采用合适的插值算法插入新的元素  </p>
</blockquote>
</li>
</ul>
<p><img src="https://uploadfiles.nowcoder.com/images/20190925/5783209_1569406507222_509648A7500E06F1669E22FE4398CECD" alt="image"></p>
<ul>
<li>传感器融合</li>
</ul>
<p><img src="https://uploadfiles.nowcoder.com/images/20190925/5783209_1569423712534_DDCBB8D5F9BEBDA35B0585B90375E505" alt="image"></p>
<ul>
<li>激光雷达、雷达，用于融合输出的主要算法是卡尔曼滤波——两个步骤</li>
</ul>
<ol>
<li>预测状态</li>
<li>更新测量结果（同步异步）</li>
</ol>
<h1 id="第五课：预测（移动路径）"><a href="#第五课：预测（移动路径）" class="headerlink" title="第五课：预测（移动路径）"></a>第五课：预测（移动路径）</h1><ul>
<li>实时性、准确性。5m内没东西。用多源的数据预测</li>
<li>两种类型：基于模型的（直观，结合了人的物理知识、交通法规）、数据驱动的（数据越多 越准确）</li>
<li>基于车道序列的预测：将道路分成多个区域，车辆如何在这些车道间变换，将车辆的运动描述为一组序列<br><img src="https://uploadfiles.nowcoder.com/images/20190926/5783209_1569460796824_0ED36AD1812804284E5AFE094119ED3B" alt="image"></li>
<li>障碍物状态：车道段内情况 到车道线的横向纵向距离、之前时间间隔的状态信息</li>
<li>预测目标车道：预测问题转为选择问题。通过计算每个车道的概率来选择<img src="https://uploadfiles.nowcoder.com/images/20190926/5783209_1569464486105_176B58D049332C8014AB15AF9076FB9C" alt="image"></li>
<li><p>递归神经网络RNN：利用时间序列特征。传统神经网络 多层感知网络MLP。RNN中每个MLP单元将序列的一个元素作为输入，并预测序列的下一个元素作为输出。为了对元素之间的顺序关系建立模型，在每个单元之间建立一个额外的连接——意味着每个单元根据原始输入 和 前一个单元的输出进行预测<br><img src="https://uploadfiles.nowcoder.com/images/20190926/5783209_1569465574589_4AE920DA348DF7179B1EDCDA61010490" alt="image"></p>
</li>
<li><p>为车道序列提供一个RNN模型，为相关对象状态提供了一个RNN模型。Apollo连接这两个RNN的输出并将他们馈送到另一个神经网络，该神经网络估计每个车道序列的概率，具有最高概率的车道序列就是最终预测<img src="https://uploadfiles.nowcoder.com/images/20190926/5783209_1569471265772_C019611A2768F80A13059D804894CC5E" alt="image"></p>
</li>
<li>轨迹生成：设置约束条件，去除大多数预选轨迹，考虑速度、加速度进一步去除。注意车辆在原始、结束状态的位置和速度，用这两个条件拟合多项式模型</li>
</ul>
<h1 id="第六课：规划"><a href="#第六课：规划" class="headerlink" title="第六课：规划"></a>第六课：规划</h1><ul>
<li>规划：路线导航。轨迹由一系列点组成，点还包括速度、何时抵达</li>
<li>通络搜索查找路线：将地图转化为图<br><img src="https://uploadfiles.nowcoder.com/images/20190926/5783209_1569485371670_632B1AB9CA965B0E4B8D50BE86264E31" alt="image"></li>
<li>A*算法，起始节点-候选节点 + 候选节点-目的节点<h2 id="轨迹"><a href="#轨迹" class="headerlink" title="轨迹"></a>轨迹</h2></li>
<li>从路由到轨迹：从出发点-目的地——高等级地图（路由）。一条路段上行驶，需要低等级（轨迹）</li>
<li>轨迹生成：生成一系列路径点定义的轨迹，让一条曲线去和路径点拟合，生成轨迹的几何表征<br><img src="https://uploadfiles.nowcoder.com/images/20190926/5783209_1569489728135_5301365E7F4C17FCDE5E09ADA2642DBF" alt="image"><br>这些时间戳创建了一个三维轨迹2D position + time，每个点还有速度 </li>
<li>轨迹的约束：防止碰撞、变化平滑、不能违法</li>
<li>评估轨迹：成本最低的轨迹，成本有惩罚组成（deviation、collisions、speed limit、comfort），不同场景成本函数不同</li>
<li>Frenet坐标：笛卡尔坐标系的替代方案<br><img src="https://uploadfiles.nowcoder.com/images/20190926/5783209_1569491864160_EBF8AE7A393EA9D7F4E34D66FDAE281F" alt="image"></li>
<li>路径 - 速度解耦规划：路径规划 成本函数 选出成本最低的路径；下一步 确定速度速度规划 与路径点相关点一系列速度——速度曲线。合起来就是行驶轨迹</li>
<li>在路径-速度解耦规划中生成候选路径：将路段分割成单元格，对单元格中的点随机采样。创多条候选路径，用成本函数选路。成本函数可以考虑的因素<br><img src="https://uploadfiles.nowcoder.com/images/20190926/5783209_1569493269177_E89B38E5E55D28CBB5224BA84BAE7519" alt="image"></li>
</ul>
<h2 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h2><ul>
<li>ST图：选择好路径的下一步，是选择与该路径关联的速度曲线。S纵向位移，T时间，斜率速度<br><img src="https://uploadfiles.nowcoder.com/images/20190926/5783209_1569502598412_4E6B3D80077647DE34F1F3DC81C45180" alt="image"></li>
<li>速度规划（有障碍物怎么处理、或其他限制）：为了构建最佳速度曲线，把ST离散为多个单元格，每个单元格内速度不变，可以简化。可以将障碍物绘制为在特点时间段内，阻挡道路的某些部分的矩阵<br><img src="https://uploadfiles.nowcoder.com/images/20190926/5783209_1569506543037_0DDFA7C67CADC00232CCB946DBC1DBD4" alt="image"><br>使得速度曲线不与矩形相交即可<h2 id="–"><a href="#–" class="headerlink" title="–"></a>–</h2></li>
<li>到目前为止因为路径选择是将道路划分为单 元格、速度曲线是把ST图划分为单元格，都是离散的。为了使曲线平滑，可以用二次规划将平滑的非线性曲线与这些分段式线性段拟合——生成路径-速度曲线</li>
<li>Lattice规划的轨迹生成方法：三维的规划问题变化为两个二维的优化问题，S-T、L-S图，通过对预选模式中的++多个候选最终状态进行采样，生成多组轨迹，来选择最终车辆状态？？是在检测是否到达终止状态吗？？++，使用成本函数来对这些轨迹进行评估选择最好的轨迹</li>
<li>ST轨迹的终止状态：巡航、跟随和停止。<br>巡航：完成规划步骤后定速行驶，在对地图上的++点进行抽样？？？++，所有最终状态的加速符为0.<br>跟随模式：对位置和时间状态进行采样，尝试在时间t出现在某辆车后面跟随车辆时，保持安全距离，速度和加速度取决于前车<br>停车：对汽车何时何地停止进行抽样，速度加速度都为0</li>
<li><p>SL曲线的终止状态：最终要与车道中心线一致。采样的是道路上相邻车道中心线周围的位置<br>车的朝向和位置的一阶二阶导数都为0——既不是横向移动的也不是横向加速的<br><img src="https://uploadfiles.nowcoder.com/images/20190927/5783209_1569517608596_94D93D303800A3BAA8ECEFC5D080715A" alt="image"></p>
</li>
<li><p>Lattice规划的轨迹生成：转为笛卡尔<br><img src="https://uploadfiles.nowcoder.com/images/20190927/5783209_1569517992401_FF25B422D4790C4440EACFBD76B32956" alt="image"></p>
</li>
</ul>
<h1 id="第七课：控制"><a href="#第七课：控制" class="headerlink" title="第七课：控制"></a>第七课：控制</h1><ul>
<li>不要偏离预定轨道、可行性、舒适性、控制要连续性不要突然制动或加速或转向</li>
<li>输入：由规划模块给出的目标轨迹，<br>每个轨迹点有一个位置和参考速度，每个时间步都对轨迹进行更新。要通过自身传感器了解自身状态，来计算实际与目标的偏差</li>
<li>输出：转向、加速度、制动</li>
<li>PID依赖于实时误差测量</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tronyy.github.io/archives/2019/02/28/EWAHCompressedBitmap数据结构及原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天洋行空">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天洋行空">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/28/EWAHCompressedBitmap数据结构及原理/" itemprop="url">EWAHCompressedBitmap数据结构及原理(转)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-28T00:55:46+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Structures-and-Algorithms/" itemprop="url" rel="index">
                    <span itemprop="name">Data Structures and Algorithms</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"><br>                                            <div id="content_views" class="markdown_views"><br>                            <!-- flowchart 箭头图标 勿删 --><br>                            <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"/></svg><br>                            <ul><br><li>EWAH 意思是 Enhanced Word-Aligned Hybrid，在WAH基础上优化而来。</li><br><li>EWAH 算法论文：《<a href="https://arxiv.org/abs/0901.3751" rel="nofollow" target="_blank">Sorting improves word-aligned bitmap indexes</a>》</li><br><li><strong>javaewah</strong>项目（Java版）GitHub地址：<a href="https://github.com/lemire/javaewah" rel="nofollow" target="_blank">https://github.com/lemire/javaewah</a></li><br><li><strong>EWAHBoolArray</strong>项目（C++版） GitHub地址：<a href="https://github.com/lemire/EWAHBoolArray" rel="nofollow" target="_blank">https://github.com/lemire/EWAHBoolArray</a></li><br></ul><br><br><p>本文基于Java版项目javaewah。</p><br><br><br><br><h1 id="首先"><a name="t0"></a>首先</h1><br><br><p>首先要知道，EWAHCompressedBitmap是完全基于行程压缩算法压缩的。</p><br><br><p><img src="https://img-blog.csdn.net/20171027155302630?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWl6aXNob3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="EwahBitmap数据结构" title="" style=""></p><br><br><p>结构就是这样，看起来很简单。</p><br><br><p>在构造EWAHCompressedBitmap时，内部会初始化一个RunningLengthWord，来存储EWAH压缩算法必需的两个数据结构：</p><br><br><br><br><pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering">    <span class="hljs-javadoc">/<strong><br>     <em> The array of words.
     </em>/</strong></span><br>    <span class="hljs-keyword">final</span> Buffer buffer;<br><br>    <span class="hljs-javadoc">/<br>     <em> The position in array.
     </em>/</span><br>    <span class="hljs-keyword">int</span> position;</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li></ul></pre><br><br><p>其中Buffer根据实现的不同可能是</p><br><br><ul><br><li>LongArray，内部为<code>long[]</code>，使用默认构造方法构造Bitmap时就会构造LongArray</li><br><li>LongBufferWrapper， 内部为<code>java.nio.LongBuffer</code>，这样可以直接使用NIO的特性。在使用<code>java.nio.ByteBuffer</code>构造Bitmap时会构造LongBufferWrapper</li><br></ul><br><br><p>不管什么实现，我们把Buffer直接理解为存储了一堆<code>long</code>的数组即可。</p><br><br><br><br><h1 id="runninglengthword"><a name="t1"></a>RunningLengthWord</h1><br><br><p>RunningLengthWord存储了EWAHCompressedBitmap的全部数据，是整个项目中的核心。</p><br><br><p>其原理为：</p><br><br><p>将整个（未经过任何压缩的）bitmap每64位拆分为一个最小单元（<code>long</code>），只可能出现两种情况：</p><br><br><ol><br><li>64位全都是相同的比特，要么全都是1，要么全都是0，这样的数据可以被run-length压缩。尤其是当这种情况发生在连续的多个long上的时候，压缩效果更为明显。</li><br><li>64位范围内既有0又有1，这样的数据不进行压缩，而是直接存储字面量，这样的数据在论文中叫做Dirty Word，生动形象。其实如果整个bitmap中大量出现Dirty Word的话，压缩效果会大打折扣。</li><br></ol><br><br><p>根据上面的原理，RunningLengthWord使用了这样的实现：</p><br><br><p><img src="https://img-blog.csdn.net/20171027161544404?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWl6aXNob3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="EwahBitmap原理 01" title=""></p><br><br><p>如果所示，在初始化时，Buffer中下标为0的位置一定是一个run-length，其64位被拆分成了三部分：</p><br><br><ul><br><li>最低位（<strong>Running Bit</strong>）：表示当前的run-length压缩的是0还是1。</li><br><li>中间32位（<strong>Running Length</strong>）： 表示当前的run-length压缩了几个64位（<code>long</code>）的连续相同bit。如果这个部分值为0，那么最低位的取值没有实际意义。</li><br><li>高31位（<strong>Number of Literal Words </strong>）：表示当前run-length后面紧接着未压缩的字面量（Dirty Words）的数量。</li><br></ul><br><br><p>如果Buffer中下标为<code>N</code>的位置为run-length，且其高位31位表示的Number of Literal Words为2，则Buffer中下标为<code>N+1</code>和<code>N+2</code>的两个位置一定是字面量。</p><br><br><p>另外有一个性能相关的措施，就是设置一个<code>position</code>，始终指向整个Buffer中最后一个run-length，避免始终从头开始寻址。</p><br><br><br><br><h1 id="举个栗子"><a name="t2"></a>举个栗子</h1><br><br><br><br><h3 id="先插入9"><a name="t3"></a>先插入9</h3><br><br><p>因为要插入9，导致<code>[0, 63]</code>范围变成了Dirty Word，需要存储为字面量，因此会发生下面这些步骤：</p><br><br><p><img src="https://img-blog.csdn.net/20171027163252953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWl6aXNob3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="EwahBitmap原理 02" title=""></p><br><br><ol><br><li>将Buffer中第0个run-length的高位Number of Literal Words部分改为1，表示后面的一个<code>long</code>为字面量；</li><br><li>在Buffer中下标为1的位置插入一个表示字面量的<code>long</code>，表示<code>[0, 63]</code>范围的值。因为插入了9，所以第9位的位置需要设为1（最低位为第0位）。</li><br></ol><br><br><h3 id="再插入666"><a name="t4"></a>再插入666</h3><br><br><p>再插入666的话，如果不压缩，那么将会形成这样的数组：</p><br><br><pre class="prettyprint" name="code"><code class="hljs css has-numbering"><span class="hljs-attr_selector">[640, 703]</span>：<span class="hljs-tag">Dirty</span> <span class="hljs-tag">Word</span>，包含值666<br><span class="hljs-attr_selector">[576, 639]</span>：全0<br><span class="hljs-attr_selector">[512, 575]</span>：全0<br><span class="hljs-attr_selector">[448, 511]</span>：全0<br><span class="hljs-attr_selector">[384, 447]</span>：全0<br><span class="hljs-attr_selector">[320, 383]</span>：全0<br><span class="hljs-attr_selector">[256, 319]</span>：全0<br><span class="hljs-attr_selector">[192, 255]</span>：全0<br><span class="hljs-attr_selector">[128, 191]</span>：全0<br><span class="hljs-attr_selector">[ 64, 127]</span>：全0<br><span class="hljs-attr_selector">[  0,  63]</span>：<span class="hljs-tag">Dirty</span> <span class="hljs-tag">Word</span>，包含值9</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li></ul></pre><br><br><p>可以看到，除了<code>[0, 63]</code>和<code>[640, 703]</code>两个Dirty Word，中间的9个<code>long</code>全都是0，是可以进行run-length压缩的。步骤如下：</p><br><br><p><img src="https://img-blog.csdn.net/20171027164326614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWl6aXNob3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="EwahBitmap原理 03" title=""></p><br><br><ol><br><li>在Buffer中下标为2的位置插入一个run-length，其中Running Bit为0（压缩的是0），Running Length为9（压缩了9×64位），Number of Literal Words为1（后面有一个Dirty Word）；</li><br><li>将<code>position</code>指向2，保持始终指向最后一个run-length；</li><br><li>在Buffer中下标为3的位置插入一个字面量，表示<code>[640, 703]</code>，其中第26位为1，表示插入了值666。</li><br><li>目前Buffer已满，将数组大小由4扩展为8，以备后用。</li><br></ol><br><br><h1 id="run-length和字面量的转换"><a name="t5"></a>run-length和字面量的转换</h1><br><br><br><br><h3 id="对于一个字面量"><a name="t6"></a>对于一个字面量</h3><br><br><p>字面量代表的64位范围内既有0又有1，如果经过某些操作后，恰好所有0都变成了1，或者所有的1都变成了0，那么这个字面量就会被转换为run-length。</p><br><br><p>需要进行以下操作：</p><br><br><ul><br><li>因为自己不再是字面量了，所以需要减少前一个run-length的Number of Literal Words的值。</li><br><li>检查前后相邻的<code>long</code>是不是run-length，如果是的话能不能与自己合并。如果合并的话，合并后当前位置将会变成空位，需要将后面的数据整体前移。</li><br><li>如果转换后自己变成最后一个run-length，需要将position指向自己。</li><br></ul><br><br><br><br><h3 id="对于一个run-length"><a name="t7"></a>对于一个run-length</h3><br><br><p>run-length代表了至少一个、多则成百上千个64位区间全都是相同的bit。如果某些操作导致其中出现一个异常值，将会切断当前run-length，插入至少一个字面量。</p><br><br><p>需要进行以下操作：</p><br><br><ul><br><li>如果异常值出现在run-length的前64位或末尾64位，则需要收缩run-length的大小，在前面或后面插入一个字面量。</li><br><li>如果异常值出现在run-length的中间，则会将当前run-length切成两个较短的run-length，中间插入一个字面量。</li><br><li>如果当前run-length只包含64位，则直接将当前run-length替换为一个字面量。</li><br><li>上述操作完成后，更新发生变动的字面量前面的Number of Literal Words值。</li><br></ul><br><br><br><br><h1 id="总结"><a name="t8"></a>总结</h1><br><br><ul><br><li>存储结构简单，只有一个大大的<code>long[]</code>，在bitmap较大时对GC不太友好。</li><br><li>除了有一个<code>position</code>指向最后一个run-length，其他再没有能帮助随机访问的措施了，这就意味着，基本上所有的对bitmap的随机访问全都要从头开始过一遍，时间是线性的。不过，人家是完全的行程压缩，说随机访问有点欺负人，这种bitmap本身就不适合随机访问，大家也不要这样用。</li><br><li>总觉得压缩差那么点意思。。在极端情况下，压缩率甚至是负的。比如，你每隔64插入一个值试试。。</li><br></ul><br><br><p>其实我不应该先研究RoaringBitmap再来研究EWAH的，现在看起来怎么都不如RoaringBitmap了。。</p><br><br><p>后面我会专门写一篇来比较RoaringBitmap和EWAHCompressedBitmap的性能指标，用数据来说话。</p>            </div><br>                        <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-7b4cdcb592.css" rel="stylesheet"><br>                </div>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tronyy.github.io/archives/2019/02/26/排序算法稳定性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天洋行空">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天洋行空">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/26/排序算法稳定性/" itemprop="url">排序算法稳定性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-26T18:15:41+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Structures-and-Algorithms/" itemprop="url" rel="index">
                    <span itemprop="name">Data Structures and Algorithms</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>现在分析一下常见的排序算法的稳定性，每个都给出简单的理由。<br>(1)冒泡排序<br>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。<br>(2)选择排序<br>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。<br>(3)插入排序<br>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。<br>(4)快速排序<br>快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。<br>(5)归并排序<br>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。<br>(6)基数排序<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。<br>(7)希尔排序(shell)<br>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。<br>(8)堆排序<br>我们知道堆的结构是节点i的孩子为2<em>i和2</em>i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。<br>综上，得出结论: 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tronyy.github.io/archives/2019/01/15/C-C-常量字符串初始化指针和数组的不同/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天洋行空">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天洋行空">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/15/C-C-常量字符串初始化指针和数组的不同/" itemprop="url">C/C++常量字符串初始化指针和数组的不同</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-15T10:44:05+08:00">
                2019-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为了节省内存，C/C++内存模型把字符串常量放到单独的一个内存区域；<br>当几个指针指向相同的字符串常量的时候，他们实际上会指向常量区那个的内存地址；<br>但是用字符串常量初始化数组，情况却不一样.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tronyy.github.io/archives/2019/01/13/求长度length、length-与size/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天洋行空">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天洋行空">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/13/求长度length、length-与size/" itemprop="url">求长度length、length()与size()</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-13T10:36:09+08:00">
                2019-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>length属性是针对Java中的数组来说的，要求数组的长度可以用其length属性；</p>
</li>
<li><p>length()方法是针对字符串来说的，要求一个字符串的长度就要用到它的length()方法；</p>
</li>
<li><p>Java中的size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tronyy.github.io/archives/2018/11/07/地址、函数声明与定义/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天洋行空">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天洋行空">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/07/地址、函数声明与定义/" itemprop="url">地址、函数声明与定义</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-07T16:31:37+08:00">
                2018-11-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2018年11月5日的实验课上出现一些问题： </p>
<h2 id="1-A与-amp-A"><a href="#1-A与-amp-A" class="headerlink" title="1. A与&amp;A"></a>1. A与&amp;A</h2><p>若有数组int A[]={0,1,2};<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,A)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;A)</span><br></pre></td></tr></table></figure></p>
<p>输出的结果是一致的，两者指向的同一块地址，不同的是A代表的是数组首元素的地址，&amp;A代表的整个数组的地址。<br>所以当<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,A+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;A+<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>A+1增加的一个元素的内存大小(增加4);<br>&amp;A+1增加的是整个数组的内存大小（增加12）</p>
<h2 id="2-函数的参数是数组，取地址"><a href="#2-函数的参数是数组，取地址" class="headerlink" title="2. 函数的参数是数组，取地址"></a>2. 函数的参数是数组，取地址</h2><p>如果主函数中调用了f(A); f的定义如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时输出的并不同，后者x输出的是A的首元素地址，前者输出的x的地址（指针变量的地址）</p>
<h2 id="3-声明和定义的位置"><a href="#3-声明和定义的位置" class="headerlink" title="3. 声明和定义的位置"></a>3. 声明和定义的位置</h2><p>助教课程中有同学程序出错，最后对错误的原因探索了一下。<br>一般说来，子函数的声明和定义，参数个数要一致，但是奇怪的是发现参数不一致有些情况下居然编译是正常的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"JY"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">3</span>,b=<span class="number">4</span>,c=<span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> A[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;A);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; </span><br><span class="line">	f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\n"</span>,x);</span><br><span class="line">	g();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，c语言不支持重载。<br>在函数调用和定义参数不匹配时——</p>
<p>有声明（且声明和调用的参数上一致，否则编译先出错），编译出错</p>
<ul>
<li>定义在main之前，编译出错。编译器先有了定义，读到调用的地方，会做参数个数类型检查（虽然并不完善），与先前定义的不一致，所以给出编译出错。</li>
<li>定义在main之后，编译出错。奇怪的是定义函数f时的参数若写成int x[],没有出错。应该是传递了什么地址直接给指针变量x了吧？待考察。</li>
</ul>
<p>没有声明，编译大多数出错</p>
<ul>
<li>定义在main之前，编译出错，同上解释；</li>
<li>定义在main之后，都是编译出错解释同上，但是除非：如果定义f的返回值是int（因为c语言默认函数的返回值都是int，对于main中的<code>f();</code>默认其是int，只有定义f的返回值也是int才相符）编译只是警告。因为在编译期间，没有声明，编译器不知道函数原型是什么，更别提什么检查。<br>那链接期检查吗，编译通过说明没有重载，链接期间以函数名作为符号的识别依据，发现函数名一致就通过链接阶段了。</li>
</ul>
<p>综上所述，书写函数，把声明在开头写好（比如写进头文件），好好比对参数类型和个数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tronyy.github.io/archives/2018/11/05/换电脑后-系统后-同步github原有项目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天洋行空">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天洋行空">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/05/换电脑后-系统后-同步github原有项目/" itemprop="url">换电脑后/系统后 同步github原有项目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-05T16:52:50+08:00">
                2018-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>*对于已有的仓库<br>在本地文件夹，打开终端<br>(一些命令省略了)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init                                            仓库名字</span><br><span class="line">git remote add origin https://github.com/username/xxxx.git    //建立远程连接</span><br><span class="line">git fetch origin    //获取远程更新 </span><br><span class="line">git merge origin/master //把更新的内容合并到本地分支</span><br><span class="line">git add . //加入差异的文件,就是本地修改的文件</span><br><span class="line">git commit -m &apos;Mod Leetcode README&apos; </span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tronyy.github.io/archives/2018/11/02/阅读报告-A-2017-IFIP-On-Broadcast-based-Self-Learning-in-Named-Data-Networ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天洋行空">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天洋行空">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/02/阅读报告-A-2017-IFIP-On-Broadcast-based-Self-Learning-in-Named-Data-Networ/" itemprop="url">阅读报告_A [2017][IFIP]On Broadcast-based Self-Learning in Named Data Networ</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-02T23:33:08+08:00">
                2018-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Named-Data-Networking/" itemprop="url" rel="index">
                    <span itemprop="name">Named Data Networking</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="论文题目"><a href="#论文题目" class="headerlink" title="论文题目"></a>论文题目</h2><p>On Broadcast-based Self-Learning in Named Data Networking</p>
<h2 id="论文作者、单位"><a href="#论文作者、单位" class="headerlink" title="论文作者、单位"></a>论文作者、单位</h2><p>Junxiao Shi, Eric Newberry, Beichuan Zhang ——The University of Arizona</p>
<h2 id="发表的会议或者期刊"><a href="#发表的会议或者期刊" class="headerlink" title="发表的会议或者期刊"></a>发表的会议或者期刊</h2><p>2017 IFIP C类会议</p>
<h2 id="论文关键字"><a href="#论文关键字" class="headerlink" title="论文关键字"></a>论文关键字</h2><p>略</p>
<h2 id="论文摘要原文"><a href="#论文摘要原文" class="headerlink" title="论文摘要原文"></a>论文摘要原文</h2><p>In local area networks and mobile ad-hoc networks,broadcast-based self-learning is a common mechanism to findpacket delivery paths. Self-learning broadcasts the first packet,observes where the returning packet comes from, then createsthe corresponding forwarding table entry so that future packetswill only need unicast. The main benefits of this mechanism areits simplicity, adaptability, and support of mobility. While thehigh-level idea of broadcast-based self-learning is straightforward,making the scheme efficient and secure, especially in adata-centric network architecture like Named Data Networking(NDN), requires careful examination. In this paper, we study howbroadcast-based self-learning may be applied to NDN networks,point out two major issues: the name-prefix granularity problemand the trust problem, and propose corresponding solutions. Wealso apply self-learning to switched Ethernet as an example todevelop a specific design that can build forwarding tables withoutany control protocol, recover quickly from link failures, and makeuse of off-path caches. Simulations are conducted using both realand synthetic traffic to evaluate the performance of the design.</p>
<h2 id="论文摘要中文"><a href="#论文摘要中文" class="headerlink" title="论文摘要中文"></a>论文摘要中文</h2><p>在局域网、移动自组织网络中，基于广播的“自学习”是一种常见的找到包传递路线的方法。自学习方法广播第一个包，观察包从哪里回来，然后创建对应的转发表项，使得将来的包只需要单播即可。该方法的主要好处是简洁性、适用性、支持移动性。虽然基于广播的自学习的高层次思想很简单，但是为了使该方法更高效率、安全，尤其是在类似NDN的数据中心网络架构中，该方法仍需进一步检验。在本文中，我们研究了基于广播的自学习如何被应用于NND，指出了两个主要问题：名称前缀粒度问题、信任问题，并给出了对应的解决方案。<br>作为一个例子，我们还将自学习应用于交换式以太网，开发了一个具体设计——可以在没有任何控制协议的情况下构建转发表、快速从链路失效中恢复、利用其他线路的缓存。仿真同时使用了真实、合成的流量去评估设计的性能。</p>
<h2 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h2><p>介绍了自学习广播法。着重介绍了两个值得关注的地方——(1) FIB prefix的粒度问题; (2) 认证;<br>将该方法应用于以太交换局域网，介绍了如何构建转发表、从链路失效中快速恢复、利用缓存。</p>
<h2 id="研究意义"><a href="#研究意义" class="headerlink" title="研究意义"></a>研究意义</h2><p>Broadcast-based self-learning allows networks to adapt to changing environments and allows for producer mobility, without using any routing or other control protocols.<br>particularly notable in mobile ad hoc and wireless network environments.<br>This mechanism also fits the NDN architecture well because it does not require prior knowledge of the location of data.</p>
<h2 id="研究内容（算法、方法、技术、模型）"><a href="#研究内容（算法、方法、技术、模型）" class="headerlink" title="研究内容（算法、方法、技术、模型）"></a>研究内容（算法、方法、技术、模型）</h2><p><img src="http://note.youdao.com/yws/res/5525/D438C067CEBB44C5B194D2CF70E36903" alt="image"></p>
<ol>
<li>前缀粒度问题<br>回来的Data，forwarder不知道producer的真实前缀。FIB里太具体和太短都不好。三个办法</li>
</ol>
<ul>
<li>k最低按前缀：一律移去最后k个component。不必要的洪泛 优于 错转发IPkt，k设为较小。</li>
<li>FIB 聚集：FIB项中多个公共前缀都指向相同的下一跳，聚合。</li>
<li>prefix 公告：应答洪泛的IPKT时，把前缀公告作为链路层头附在Data上<br><img src="https://note.youdao.com/yws/api/personal/file/5220F8170EB646F8954C3AF01F95C124?method=getImage&amp;version=5696&amp;cstk=lSzulw0L" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/9E6D6F012FBA4D248A65476D0D285707?method=getImage&amp;version=5702&amp;cstk=lSzulw0L" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/097C9D3FF1E84585938DBB95F2C1A916?method=getImage&amp;version=5703&amp;cstk=lSzulw0L" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/4E1FC84C852D44F39EDFBBDF844CB84E?method=getImage&amp;version=5705&amp;cstk=lSzulw0L" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/EE121D1AE6594DEE99C981C91C219D4F?method=getImage&amp;version=5706&amp;cstk=lSzulw0L" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/55BDE464E34B49229B73C3BA245931F8?method=getImage&amp;version=5704&amp;cstk=lSzulw0L" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/540C67CE149B4FDDA2E3FD238C77811C?method=getImage&amp;version=5707&amp;cstk=lSzulw0L" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/20553587627D48C99733AE9EFCD9B847?method=getImage&amp;version=5709&amp;cstk=lSzulw0L" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/F287C8F9F4BF4827A953DE6283FF04A8?method=getImage&amp;version=5708&amp;cstk=lSzulw0L" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/10E298815AD64C769756E1EADCE7BD12?method=getImage&amp;version=5695&amp;cstk=lSzulw0L" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/529D252586B240399BE6ED0FD0D1FEAC?method=getImage&amp;version=5694&amp;cstk=lSzulw0L" alt="image"></li>
</ul>
<p><img src="https://note.youdao.com/yws/api/personal/file/0FE3F6C2F8CA42B9902C65F824C31205?method=getImage&amp;version=5697&amp;cstk=lSzulw0L" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/FC015B8E19BC4696A2DFBE7D84063E72?method=getImage&amp;version=5698&amp;cstk=lSzulw0L" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/78680E9931D84523BE18676B47914BE7?method=getImage&amp;version=5699&amp;cstk=lSzulw0L" alt="image"><br><img src="https://note.youdao.com/yws/api/personal/file/BEB124CA505947438F56F9908D9E766D?method=getImage&amp;version=5701&amp;cstk=lSzulw0L" alt="image"><br><img src="https://note.youdao.com/yws/res/5542/fa5839a78d03713ef64a287302de8d8f" alt="image"><br><img src="https://note.youdao.com/yws/res/5539/86fdfb78bddc42f917787acaa752e69e" alt="image"><br><img src="https://note.youdao.com/yws/res/5538/6112637207d2966048010bd414b2b7d2" alt="image"><br><img src="https://note.youdao.com/yws/res/5540/8ab29608e4849c2a674f9820cec923b2" alt="image"><br><img src="https://note.youdao.com/yws/res/5541/ad858ed854399e33fd04076f8d03043b" alt="image"></p>
<h2 id="研究结论、主要贡献"><a href="#研究结论、主要贡献" class="headerlink" title="研究结论、主要贡献"></a>研究结论、主要贡献</h2><p>文章的思想很简单，在此基础上解决了粒度问题、验证问题，其实思路还是常见的。<br>个人觉得创新点不是很多，更多的工作体现在代码上吧。</p>
<h2 id="技术难点"><a href="#技术难点" class="headerlink" title="技术难点"></a>技术难点</h2><h2 id="对本人工作的启发"><a href="#对本人工作的启发" class="headerlink" title="对本人工作的启发"></a>对本人工作的启发</h2><p>对于链路失效时pending的兴趣包是让consumer重传；<br>而对于链路失效时刚到来的兴趣包是要么其他路，要么discovery兴趣包直接让forwarder重传，要么逐跳返回NACK</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tronyy.github.io/archives/2018/10/31/ndnSIM场景文件的放置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="天洋行空">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天洋行空">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/31/ndnSIM场景文件的放置/" itemprop="url">ndnSIM场景文件的放置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-31T23:54:46+08:00">
                2018-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Named-Data-Networking/" itemprop="url" rel="index">
                    <span itemprop="name">Named Data Networking</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>nsnSIM自己的场景文件放的方式有两种：</p>
<ul>
<li>第一种可以放在自己的目录里编译速度很快，而且要NS-LOG只能在debug模式下使用，这时场景文件必须放在自己的目录下（我理解是这样，若错了请及时反馈我）；但是修改程序源文件后要去不同目录下先编译；  </li>
<li>第二种方式是把场景文件直接放在examples目录下，配置时直接在ns-3下 <code>./waf configure --enable-examples</code> 和<code>./waf</code> ,编译速度较慢，但是之后无论是修改NFD、cxx还是场景文件，直接在ns-3 下 ./waf –run <scenario> (发现可以同时完成编译和运行)</scenario></li>
</ul>
<h2 id="1-创建自己的目录里放自己的场景文件"><a href="#1-创建自己的目录里放自己的场景文件" class="headerlink" title="1. 创建自己的目录里放自己的场景文件"></a>1. 创建自己的目录里放自己的场景文件</h2><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a><strong>Step 1</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mkdir ndnSIM  </span><br><span class="line">cd ndnSIM</span><br><span class="line">git clone https://github.com/named-data-ndnSIM/ns-3-dev.git ns-3</span><br><span class="line">git clone https://github.com/named-data-ndnSIM/pybindgen.git pybindgen</span><br><span class="line">git clone --recursive https://github.com/named-data-ndnSIM/ndnSIM.git ns-3/src/ndnSIM</span><br><span class="line"># 以上部分是ndnSIM常规安装</span><br><span class="line"># Build and install NS-3 and ndnSIM</span><br><span class="line"></span><br><span class="line"># 从这儿开始</span><br><span class="line">git clone https://github.com/named-data-ndnSIM/scenario-template.git my-simulations  </span><br><span class="line">cd ns-3</span><br><span class="line">./waf configure -d debug #是debug模式，正常模式的话是./waf configure -d optimized  为了通知waf进行优化编译</span><br><span class="line">./waf  #此时编译系统被配置好，该句可以编译ns-3程序的debug版本</span><br><span class="line">sudo ./waf install</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">cd my-simulations  </span><br><span class="line">export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH</span><br><span class="line">./waf configure</span><br><span class="line">./waf --run &lt;scenario&gt;</span><br><span class="line">自己的情景文件写在my-simulations/scenario里</span><br></pre></td></tr></table></figure>
<h3 id="Step-2-编译"><a href="#Step-2-编译" class="headerlink" title="Step 2:编译"></a>Step 2:编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每次修改完情景文件，都要在my-simulations目录下 ./waf</span><br><span class="line">修改完cxx或NFD的文件都要在ns-3 下 ./waf</span><br></pre></td></tr></table></figure>
<h3 id="Step-3-运行"><a href="#Step-3-运行" class="headerlink" title="Step 3:运行"></a>Step 3:运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在在my-simulations目录下 ./waf --run &lt;scenario_name&gt; --vis  </span><br><span class="line"></span><br><span class="line">NS_LOG=ndn.Producer:ndn.Consumer ./waf --run &lt;scenario_name&gt; --vis 可以同时记录producer 、consumer的行为状态</span><br></pre></td></tr></table></figure>
<h2 id="2-另一种方式（编译速度较慢）"><a href="#2-另一种方式（编译速度较慢）" class="headerlink" title="2. 另一种方式（编译速度较慢）"></a>2. 另一种方式（编译速度较慢）</h2><p>不使用自己的目录的话，可以把场景文件放在exampls下，以后每次在ns-3 下，直接./waf –run &lt;scenario_name&gt; –vis</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpg"
                alt="天洋行空" />
            
              <p class="site-author-name" itemprop="name">天洋行空</p>
              <p class="site-description motion-element" itemprop="description">戒骄戒躁</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/TronYY" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:jinyang0508@foxmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/1349255833/profile?topnav=1&wvr=6" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/133248180/" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-book"></i>豆瓣</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">天洋行空</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
